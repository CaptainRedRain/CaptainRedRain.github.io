<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dabbler</title>
  
  <subtitle>你来人间一趟，你要看看太阳</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://captainhong.com/"/>
  <updated>2017-10-21T17:54:22.000Z</updated>
  <id>http://captainhong.com/</id>
  
  <author>
    <name>Captain</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于《龙族》</title>
    <link href="http://captainhong.com/2017/10/21/%E5%85%B3%E4%BA%8E%E3%80%8A%E9%BE%99%E6%97%8F%E3%80%8B/"/>
    <id>http://captainhong.com/2017/10/21/关于《龙族》/</id>
    <published>2017-10-21T13:08:17.000Z</published>
    <updated>2017-10-21T17:54:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>听说《上海堡垒》要拍电影了，想来江南是要忙着做编剧去了，不知道龙五又要等到什么时候。谈到《龙族》不得不吐槽作者，还从来没见过哪个作家拖稿的时间比写书都长的，毕竟他主业太多，写书只是副业。</p><p>我应该是大一开始追海贼和妖尾，追龙族却是从高二开始的。今年妖尾完结了，龙五还遥遥无期。高中的时候没多少课余时间，一周只有半天假，还是磕磕绊绊地追了两部。因为看了龙族，后来又顺带看了《此间的少年》和《九州缥缈录》，但都不像龙族这样让我钟意。</p><p>龙族并不是第一眼就讨人喜欢的，主角又衰又懦弱，一副小心翼翼垂头丧气的样子，读起来并不酣畅淋漓。诺诺正是在他最糗的时候出场的，她光芒四射，目光如刀，牵起这个衰仔，高傲地穿过人群。</p><blockquote><p>人一生里总有几次觉得自己看见了天堂之门洞开，路明非等了十八年，在他最衰的那一刻，门开了。</p></blockquote><p>我最开始并不喜欢路明非，吸引我看下去的是满身棱角，骄傲又耀眼的诺诺。</p><hr><p>看龙族的女生可能有三分之一喜欢凯撒，英俊，多金，霸道，偏偏又专一，找不到破绽。应该还有三分之一喜欢楚子航，沉默，冷静，仗义，又强得离谱。余下的大概也没多少喜欢路明非，因为他确实从头衰到脚。<br>然而路明非才是大部分人的样子。有想做的事，想保护的人，但是他实在太衰了，只能窝在角落里，目光呆滞，盯着聚光灯下的凯撒牵着诺诺的手，还要嘟囔着学姐你要幸福这样的烂话。</p><blockquote><p>最孤单的人分两种，一种恨不得全世界都跟他一样倒霉，一种则希望别人能幸福，因为看到幸福的人，他也略略觉得温暖。</p></blockquote><p>他总是这样衰，衰到忘记是自己卖掉灵魂斩了龙王，是自己在三峡的水底拼命救下的诺诺。他做了想做的事，保护了要保护的人，站在聚光灯下的依然不是他，于是他认了命，以为自己只能是个衰人。<br>我一直在等待路明非撕掉懦弱的面具，穿越荒原，竖起战旗，哪怕失去灵魂，背叛世界，也不要耷拉着脑袋，满嘴烂话。但是直到第四部，他还是唯唯诺诺灰头土脸。</p><hr><p>龙族是本很难定性的小说。它看起来像是中二的屠龙故事，又好像是衰仔的自我救赎。谁也不知道江南最想表达什么，但我看来它更像是孤独者的狂欢。<br>龙族里的每一个主角几乎都是孤独的。<br>凯撒似乎是最不应该孤独的。他几乎拥有一切，生来就是领袖，注定是屠龙的英雄。于是便也没有人在乎他其实也只是个破小孩。当他遇到诺诺，好像从井口照下一道光，人生中又多了其他寄托。凯撒这样的人，愿意满世界地追着一个女孩跑，也就不难理解了。他那么孤独，如果没有诺诺，就只有自己一个人了。</p><p>楚子航则不同，他是一眼就看得出的孤独。他的孤独更多是因为愧疚。在雨中的高架桥上，看着嬉皮笑脸一事无成的老爸挥舞着太刀淹没在死侍中，他只能开着迈巴赫惊恐地逃走。从那天起他再也没有畏惧过，即使一个人面对龙王。对于楚子航，最大的荣耀应该是和父亲一起战死吧。后来他遇到了夏弥，似乎终于有人要从孤独中拉他出来了。楚子航动了心，女孩却是条龙，他最后的牵绊也留在北京地铁下的尼伯龙根里了。</p><p>昂热的孤独隐藏得更深。他的孤独是仇恨，是屠龙的狂热。一个一百多岁的老头，每天混迹于上流酒宴，搂着法国名模谈笑风生。但当他面对真正的龙类时似乎变了一个人。不再是沉着的屠龙领袖，更像杀红眼的亡命之徒。只有那些跟他一样老得掉了牙的伙计才知道，眼看着同伴一个一个死在面前，昂热是怎么坚持活下来的。他孤独到靠着仇恨支撑自己生的希望。</p><p>而路明非，大概是孤独的极点了。明知道什么事都不可能，还非要揣着希望，明明想为什么人把命都赌上，可是连下注的理由都没有。</p><blockquote><p>你最爱的人，你为他做了很多事，但他不知道，因为你觉得做这些事都是应该的，你忘记跟他说了。</p></blockquote><p>他的孤独，是从不被需要。没有人觉得他多重要，没有人关心他做了什么，渐渐连他自己都觉得自己是多余的。唯一关心他的人，是一心想买断他灵魂的路鸣泽。这是一个死结，只有他歇斯底里卖掉灵魂的时候，才略微感觉自己被需要，可当他真的卖光了灵魂，就只剩下无尽的孤独了。不管是人还是龙，路明非都注定踽踽独行。</p><hr><p>路明非也不是一直这么可怜，至少有一段时间不是。<br>龙族里的女性角色都很棒，不论是零，诺诺，酒德麻衣还是苏恩曦，但是绘离衣更让人难忘。很多人最开始喜欢绘离衣，大概是因为只有她喜欢路明非吧。她血统纯正，心智却不足，就像活在自己世界里的孩子，很难定义她对路明非的喜欢。但是对她来说，路明非一定很重要，比自己都重要。</p><blockquote><p>“04.24，和Sakura去东京天空树，世界上最暖和的地方在天空树的顶上。”<br>“04.25，和Sakura去明治神宫，有人在那里举办婚礼。”<br>“04.26，和Sakura去迪士尼，鬼屋很可怕，但是有Sakura在，所以不可怕。”<br>“Sakura最好了。”</p></blockquote><p>绘离衣的日记里都是他。你以为她是公主拥有全世界，可她以为她只有你和她的玩具们。<br>明明路明非那么渴望关心，终于有人视他如生命他却没有抓住。小怪兽终究要被正义的奥特曼杀死，他没能像救诺诺那样救绘离衣。真可悲，为了救诺诺，路明非毅然决然卖掉灵魂，但是救绘离衣的时候他却犹豫了，即使她说Sakura最好了。江南收了那么多刀片还是写死了绘离衣，也许他觉得路明非就应该是一个人，是走向深渊，还是涅槃重生。</p><hr><p>龙族的故事本身并不是一个悲剧，恰好相反，它读起来更像是一本轻喜剧。江南把孤独和死亡都表达的不那么沉重。只是读书的人习惯把自己代入角色，揣测文字下面的情感。</p><blockquote><p>Lonely kid hides in heart.</p></blockquote><p>每个人心里都住着一个死小孩。我甚至有些期待路明非把灵魂卖光的时刻，即使变成魔鬼，会遗忘，会哭泣，也好过把自己扮成小丑，笑的那么难看。在龙四的结尾，路明非卖掉了自己最后四分之一的灵魂，依旧是为了诺诺。这次，诺诺看见了他，也终于记起三峡水底大喊着不要死的那张脸，狰狞又悲伤。当孤独的死小孩拥有了力量，即使是奥丁，即使是昆古尼尔也没法洞穿他。利爪和重剑划出黑红色的血丝，咆哮厮杀，王与王的战争，唯有死亡可以终止。<br>希望南大还想得起龙五，毕竟看了这么久的傻猴子，如今他终于记起自己叫孙悟空了，也该让我们看看他身披金甲，踏破凌霄。不管结果如何，至少希望傻猴子能过得逍遥自在。</p><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;听说《上海堡垒》要拍电影了，想来江南是要忙着做编剧去了，不知道龙五又要等到什么时候。谈到《龙族》不得不吐槽作者，还从来没见过哪个作家拖稿的时间比写书都长的，毕竟他主业太多，写书只是副业。&lt;/p&gt;
&lt;p&gt;我应该是大一开始追海贼和妖尾，追龙族却是从高二开始的。今年妖尾完结了，龙
      
    
    </summary>
    
      <category term="小说" scheme="http://captainhong.com/categories/%E5%B0%8F%E8%AF%B4/"/>
    
    
      <category term="小说" scheme="http://captainhong.com/tags/%E5%B0%8F%E8%AF%B4/"/>
    
      <category term="龙族" scheme="http://captainhong.com/tags/%E9%BE%99%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 - CompletableFuture</title>
    <link href="http://captainhong.com/2017/10/18/Java-8-CompletableFuture/"/>
    <id>http://captainhong.com/2017/10/18/Java-8-CompletableFuture/</id>
    <published>2017-10-18T06:41:40.000Z</published>
    <updated>2017-10-19T05:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>Java 8新增了CompletableFuture类，和stream类似，CompletableFuture也使用了Lambda表达式以及流水线思想，从这个角度来说CompletableFuture和Future的关系就跟Stream和Collection一样。<br>既然CompletableFuture和Stream在设计上有相似之处，而且stream提供了并行流，不妨先从比较两者的关系入手。<br>CompletableFuture类提供了大量精巧的工厂方法，使用这些方法能更容易地完成整个流程：先看其中一个工厂方法的两个版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span>;</div></pre></td></tr></table></figure><br>supplyAsync接受生产者Supplier作为参数返回CompletableFuture对象，对象完成异步执行后会读取调用生产者方法返回值。第一种版本会把生产者方法交由ForkJoinPool池中的某个执行线程，第二种重载版本传递第二个参数指定线程执行生产者方法。<br>《Java 8实战》中有一个比较CompletableFuture和并行流的例子: 如果一个方法需要去查询所有商店某个产品的价格，获取产品价格的方法为getPrice(String product)，假设这个方法会向商店发出网络请求并操作数据库，耗时较多。<br>首先是顺序查询方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findPrices</span><span class="params">(String product)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> shops.stream()</div><div class="line">        .map(shop -&gt; String.format(<span class="string">"s% price is %.2f"</span>, shop.getName(), shop.getPrice(product)))</div><div class="line">        .collect(Collectors.toList());</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>串行方法很容易理解，对一个shop列表进行流操作，依次得到每个商店该产品的价格。下面来看并行流的方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findPrices</span><span class="params">(String product)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> shops.parallelStream()</div><div class="line">        .map(shop -&gt; String.format(<span class="string">"s% price is %.2f"</span>, shop.getName(), shop.getPrice(product)))</div><div class="line">        .collect(Collectors.toList());</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>接下来是CompletableFuture方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findPrices</span><span class="params">(String product)</span></span>&#123;</div><div class="line">    list&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream()</div><div class="line">                .map(shop -&gt; CompletableFuture.supplyAsync(</div><div class="line">                            () -&gt; shop.getName() + <span class="string">"price is"</span> + shop.getPrice(product)))</div><div class="line">                .collect(Collectors.toList());</div><div class="line">    <span class="keyword">return</span> priceFutures.stream()</div><div class="line">                .map(CompletableFuture::join)   <span class="comment">//join方法和Future的get有相同含义，唯一不同是不会抛异常</span></div><div class="line">                .collect(Collectors.toList());</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>CompletableFuture和并行流很像，内部都采用同样的通用线程池，默认都是用固定数目的线程，具体线程数取决于Runtime.getRuntime.availableProcessors()的返回值。如果通用线程池大小是8，当getPrice()方法延迟足够长而商店数量增多的时候， 上面并行流和CompletableFuture方式的性能都会下降，因为8个线程都处于忙碌状态，之后的查询都要等待前面操作释放出空闲线程。并行流很难解决这种场景，而CompletableFuture具有并行流API无法提供的优势，它允许对执行器Executor进行配置，尤其是线程池的大小。<br>定制执行器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor = Executors.newFixedThreadPool(<span class="number">100</span>);</div><div class="line">...</div><div class="line">CompletableFuture.supplyAsync(() -&gt; shop.getName() + <span class="string">"price is"</span> + shop.getPrice(product), executor);</div></pre></td></tr></table></figure><br>这样商店数目增加就不会影响效率了。<br>总结：并行流和分支/合并框架更适用于实现并行处理，而CompletableFuture更适合实现并发，在同一个CPU上执行松耦合任务，充分利用CPU的核，所以CompletableFuture更适合IO密集型任务，并行流和ForkJoinPool更适合CPU密集型任务。</p><hr><h4 id="使用CompletableFuture"><a href="#使用CompletableFuture" class="headerlink" title="使用CompletableFuture"></a>使用CompletableFuture</h4><h5 id="1-创键获取CompletableFuture"><a href="#1-创键获取CompletableFuture" class="headerlink" title="1. 创键获取CompletableFuture"></a>1. 创键获取CompletableFuture</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span>;</div><div class="line"><span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span>;</div><div class="line"><span class="function"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span>;</div></pre></td></tr></table></figure><p>runAsync需要Runnable为参数，不返回任何值，如果需要处理异步操作并返回结果使用supplyAsync.</p><h5 id="2-组合futures"><a href="#2-组合futures" class="headerlink" title="2. 组合futures"></a>2. 组合futures</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//thenApply 参数function的函数描述符为 T -&gt; U</span></div><div class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span>;</div><div class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span>;</div><div class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor)</span></span>;</div><div class="line"><span class="comment">//thenCompose  参数function的函数描述符为 T -&gt; CompletableFuture&lt;U&gt;</span></div><div class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span>;</div><div class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span>;</div><div class="line">&lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span></span>;</div></pre></td></tr></table></figure><p>从方法定义看，thenCompose可以接受一个function作为参数，这个function的函数描述符是T -&gt; CompletableFuture&lt;U&gt;，它允许对两个异步操作复合流水线，比如创建两个CompletableFuture对象，对第一个CompletableFuture对象调用thenCompose，并向它传递一个函数，当第一个CompletableFuture执行完毕后，结果将作为该函数的参数，这个函数的返回值是以第一个CompletableFuture返回作为输入计算出的第二个CompletableFuture对象。例子(只为了展示用法)：<br><img src="/img/CompletableFuture1.png" alt="2-2-1"><br>首先创建一个double集合，然后第一个CompletableFuture取每一个double的intValue()，当执行完毕时调用thenCompose方法，将执行结果作为thenCompose参数中的函数的参数，计算第二个CompletableFuture对象，把每个整型转换成字符串。最后输出的结果是1 2 3 4 5。</p><h5 id="3-整合futures，无论是否依赖"><a href="#3-整合futures，无论是否依赖" class="headerlink" title="3. 整合futures，无论是否依赖"></a>3. 整合futures，无论是否依赖</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span></div><div class="line"><span class="function"><span class="params">                        BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</div><div class="line">&lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span></div><div class="line"><span class="function"><span class="params">                        BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</div><div class="line">&lt;U,V&gt; <span class="function">CompletableFuture&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,</span></span></div><div class="line"><span class="function"><span class="params">                        BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn, Executor executor)</span></span>;</div></pre></td></tr></table></figure><p><img src="/img/CompletableFuture2.png" alt="2-3-1"><br>第二个参数BiFunction定义如何将两个CompletableFuture的结果组合在一起。</p><h5 id="4-completion事件"><a href="#4-completion事件" class="headerlink" title="4. completion事件"></a>4. completion事件</h5><p>之前所说的例子都是在所有商店的返回值都取得之后才显示商品价格。如果想要商店返回商品价格第一时间就显示返回值就需要completion事件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//thenAccept</span></div><div class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</div><div class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</div><div class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action, Executor executor)</span></span>;</div><div class="line"><span class="comment">//thenRun</span></div><div class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span></span>;</div><div class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action)</span></span>;</div><div class="line"><span class="function">CompletableFuture&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action, Executor executor)</span></span>;</div></pre></td></tr></table></figure><br><img src="/img/CompletableFuture3.png" alt="2-4-1"><br>CompletableFuture类中还提供了一些其他的completion事件，可以看做给CompletableFuture注册一个回调函数，在Future执行完毕或者计算结果可用时针对性执行一些程序。</p><blockquote><p>参考：<br>《Java 8函数式编程》– Richard Warburton<br>《Java 8 in Action》– Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h4&gt;&lt;p&gt;Java 8新增了CompletableFuture类，和stream类似，CompletableFuture也使用了Lambda表达式以及
      
    
    </summary>
    
      <category term="Java" scheme="http://captainhong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://captainhong.com/tags/Java/"/>
    
      <category term="Java 8" scheme="http://captainhong.com/tags/Java-8/"/>
    
      <category term="CompletableFuture" scheme="http://captainhong.com/tags/CompletableFuture/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 - Stream</title>
    <link href="http://captainhong.com/2017/10/17/Java-8-Stream/"/>
    <id>http://captainhong.com/2017/10/17/Java-8-Stream/</id>
    <published>2017-10-17T14:02:49.000Z</published>
    <updated>2017-10-19T05:10:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h4><p>流允许以声明式方式处理数据集合，可以姑且把它们看成遍历数据集的高级迭代器。此外流可以透明地并行处理。</p><h5 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h5><p>优点</p><ul><li>声明性 — 更简洁，更易读</li><li>可复合 — 更灵活</li><li>可并行 — 性能更好</li></ul><h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h5><p>流操作有两个重要的特点</p><ul><li>流水线 — 很多流操作本身会返回一个流，这样多个操作就可以链接起来形成流水线。</li><li>内部迭代 — 流的迭代在背后进行，与显式使用迭代器不同。</li></ul><h5 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h5><p>集合和流的区别在于什么时候计算。集合中的每个元素都要先算出来才添加到集合中，流则是在概念上固定的数据结构，其元素是按需计算的。这个思想是用户仅仅从流中提取需要的值。从另一个角度看流就像延迟创建的集合。</p><h5 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h5><p>流与迭代器类似，只能遍历一次，遍历完这个流就已经被消费掉了。</p><h5 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h5><p>流操作可以分为两类，中间操作和终端操作:</p><ul><li>中间操作指可以连接起来的流操作：如filter，sorted，map和limit等，除非流水线触发终端操作，否则中间操作不会执行任何结果。</li><li>终端操作可以从流的流水线生成结果，如forEach，collect。</li></ul><h5 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h5><p>使用流一般包括三件事：</p><ul><li>一个数据源（如集合）来执行一个操作</li><li>一个中间操作链，形成流水线</li><li>一个终端操作，执行流水线并生成结果</li></ul><hr><h4 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h4><h5 id="1-筛选和切片"><a href="#1-筛选和切片" class="headerlink" title="1. 筛选和切片"></a>1. 筛选和切片</h5><p>下面列举几个常见的流<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用谓词筛选</span></div><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</div><div class="line"><span class="comment">//筛选各异的元素</span></div><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">distinct</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">//截断流，返回不超过给定长度的流</span></div><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</div><div class="line"><span class="comment">//返回扔掉前n个元素的流，如果流中元素不足n个则返回空流</span></div><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</div></pre></td></tr></table></figure><br>下面代码筛选出苹果中重于100克的第4和第5个苹果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; bigAppleList = appleList.stream().filter(apple -&gt; apple.getWeight() &gt; <span class="number">100</span>)</div><div class="line">                                    .limit(<span class="number">5</span>).skip(<span class="number">3</span>).collect(toList());</div></pre></td></tr></table></figure></p><h5 id="2-映射"><a href="#2-映射" class="headerlink" title="2. 映射"></a>2. 映射</h5><p>下面列举几个常见的流<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//map方法接受function作为参数，并被应用在每个元素上映射成新的元素</span></div><div class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</div><div class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span>;</div></pre></td></tr></table></figure><br>从flatMap的函数定义来看，它接受一个function，而这个function的第二个参数是stream，也就是说函数描述符为T→Stream<r>， Arrays中有stream()方法可以将数组转化成流。<br><img src="/img/stream1.png" alt="2-1"><br>等同于：<br><img src="/img/stream2.png" alt="2-2"><br>map被应用到数组中的两个字符串”Hello”和”World”中，映射成两个String数组，而我们想要的是Stream&lt;String&gt;而不是Stream&lt;String[]&gt;，如果用map来映射将会得到流的列表，所以需要用flatMap把各个数组映射成一个流。<br>简单来说，flatMap方法会把一个流中的每个值都转换成另一个流，然后把所有流连接起来成为一个流。</r></p><h5 id="3-查找和匹配"><a href="#3-查找和匹配" class="headerlink" title="3. 查找和匹配"></a>3. 查找和匹配</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//流中是否有一个元素匹配给定的谓词</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</div><div class="line"><span class="comment">//流中的元素是否都能匹配给定的谓词</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</div><div class="line"><span class="comment">//流中没有元素与给定的谓词匹配</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</div><div class="line"><span class="comment">//返回流中任意元素。流水线将会利用短路找到结果立即结束</span></div><div class="line"><span class="function">Optional&lt;T&gt; <span class="title">findAny</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">//找到第一个元素。在并行上限制较多，如果不关心返回元素是哪一个建议使用findAny()，因为它在并行流上限制较少</span></div><div class="line"><span class="function">Optional&lt;T&gt; <span class="title">findFirst</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure><h5 id="4-归约"><a href="#4-归约" class="headerlink" title="4. 归约"></a>4. 归约</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个参数为初始值</span></div><div class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</div><div class="line"><span class="comment">// 无初始值,考虑流中没有任何元素的情况，reduce无法返回和，所以结果包裹在Optional对象里以表明和可能不存在</span></div><div class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</div></pre></td></tr></table></figure><p>想计算整型数组的和：<br><img src="/img/stream3.png" alt="&quot;2-3&quot;"><br>结果是20。<br>reduce() 也可以用来求最大值或者最小值。</p><hr><h4 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h4><p>和函数式接口的原始类型特化一样，为避免装箱拆箱成本，Stream API提供了数值流。<br>Java 8引入三个原始类型特化流：IntStream, DoubleStream和LongStream, 分别将流中的元素特化为int，double和long，从而避免了reduce时暗含的拆箱成本。每个接口都带来了进行常用数值归约的新方法，例如count(), max(), min(), average()和sum()等。<br>映射到数值流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</div><div class="line"><span class="function">LongStream <span class="title">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</div><div class="line"><span class="function">DoubleStream <span class="title">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</div></pre></td></tr></table></figure><br>转换回对象流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stream&lt;Integer&gt; <span class="title">boxed</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure><br>使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IntStream intStream = appleList.stream().mapToInt(Apple::getWeight);   <span class="comment">//转换成数值流</span></div><div class="line">Stream&lt;Integer&gt; stream = intStream.boxed();   <span class="comment">//转换成Stream</span></div></pre></td></tr></table></figure><br>数值流中有很多实用的方法，如求数值范围，IntStream evenNumbers = IntStream.rangeClosed(1, 100);</p><hr><h4 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h4><p>除了从集合生成流，还有其他几种生成流的方式</p><h5 id="1-由值构建流"><a href="#1-由值构建流" class="headerlink" title="1. 由值构建流"></a>1. 由值构建流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"zhao"</span>, <span class="string">"hong"</span>, <span class="string">"yu"</span>);</div><div class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</div></pre></td></tr></table></figure><h5 id="2-由数组构造流"><a href="#2-由数组构造流" class="headerlink" title="2. 由数组构造流"></a>2. 由数组构造流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] name = &#123;<span class="string">"zhao"</span>, <span class="string">"hong"</span>, <span class="string">"yu"</span>&#125;;</div><div class="line">Stream&lt;String&gt; stream = Arrays.stream(name);</div></pre></td></tr></table></figure><h5 id="3-由文件生成流"><a href="#3-由文件生成流" class="headerlink" title="3. 由文件生成流"></a>3. 由文件生成流</h5><p>java.nio.file.Files中有很多静态方法可以返回一个流，例如Files.lines会返回指定文件中各行构成的字符串流。使用的不多，先不介绍。</p><h5 id="4-由函数生成流"><a href="#4-由函数生成流" class="headerlink" title="4. 由函数生成流"></a>4. 由函数生成流</h5><p>Stream API 提供了两个静态方法从函数生成流：Stream.iterate和Stream.generate。这两个操作可以创建无限流。一般会用limit来加以限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n+<span class="number">2</span>).limit(<span class="number">100</span>).forEach(System.out::println);</div></pre></td></tr></table></figure><br>生成结果是从0开始公差为2的等差数列的前100项。</p><hr><h4 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h4><p>终端操作除了count, findFirst, reduce, forEach等，最常用的是collect操作。collect接受Collector作为参数<br>Collectors类提供了很多常用的静态工厂方法生成Collector：<br><img src="/img/stream4.png" alt="4-1"></p><blockquote><p>参考：<br>《Java 8函数式编程》– Richard Warburton<br>《Java 8 in Action》– Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;流的概念&quot;&gt;&lt;a href=&quot;#流的概念&quot; class=&quot;headerlink&quot; title=&quot;流的概念&quot;&gt;&lt;/a&gt;流的概念&lt;/h4&gt;&lt;p&gt;流允许以声明式方式处理数据集合，可以姑且把它们看成遍历数据集的高级迭代器。此外流可以透明地并行处理。&lt;/p&gt;
&lt;h5 id=
      
    
    </summary>
    
      <category term="Java" scheme="http://captainhong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://captainhong.com/tags/Java/"/>
    
      <category term="Java 8" scheme="http://captainhong.com/tags/Java-8/"/>
    
      <category term="Stream" scheme="http://captainhong.com/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 - Lambda</title>
    <link href="http://captainhong.com/2017/10/16/Java-8-Lambda/"/>
    <id>http://captainhong.com/2017/10/16/Java-8-Lambda/</id>
    <published>2017-10-16T11:49:37.000Z</published>
    <updated>2017-10-16T17:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>从一个例子开始：用Lambda实现一个比较器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Apple&gt; byWeight = </div><div class="line">   (Apple apple1, Apple apple2) -&gt; apple1.getWeight().compareTo(apple2.getWeight());</div></pre></td></tr></table></figure><p>Lambda表达式有三个部分：</p><ul><li>参数列表：两个Apple</li><li>箭头：箭头把参数列表和Lambda主体分隔开</li><li>Lambda主体：比较两个Apple的重量。表达式就是Lambda的返回值</li></ul><p>Lambda表达式的基本语法有两种：</p><ul><li>(parameters) -&gt; expression</li><li>(parameters) -&gt; {statements;}</li></ul><p>注：expression隐含了return，如果想显示返回语句需要使用第二种statements语法。</p><hr><h4 id="何时使用Lambda"><a href="#何时使用Lambda" class="headerlink" title="何时使用Lambda"></a>何时使用Lambda</h4><p>我们可以在函数式接口上使用Lambda表达式。<br>函数式接口：只定义一个抽象方法的接口(比如例子中的Comparator接口只定义了一个compare()抽象方法)。<br>注：<font color="blue">Java 8中新增了默认方法，即在类没有对方法进行实现时，主体为方法提供默认实现的方法。</font>不管有多少默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。</p><hr><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口很有用，因为抽象方法的签名可以描述Lambda表达式的签名，函数式接口的抽象方法签名称为函数描述符。<br>java.util.function包中定义了一些常用的函数式接口：<br>(注：@FunctionalInterface 注解用于表示该接口会设计成一个函数式接口。接口代码省略了默认方法)。</p><h5 id="1-Predicate"><a href="#1-Predicate" class="headerlink" title="1) Predicate"></a>1) Predicate<t></t></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Predicate接口定义了一个test抽象方法，接受泛型T对象，返回一个boolean。适用于filter中。</p><h5 id="2-Consumer"><a href="#2-Consumer" class="headerlink" title="2) Consumer"></a>2) Consumer<t></t></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;    </div></pre></td></tr></table></figure><p>Consumer定义了一个accept抽象方法，接受泛型T对象，没有返回。如果需要访问一个对象并对其执行某些操作就可以使用这个接口。</p><h5 id="3-Function"><a href="#3-Function" class="headerlink" title="3) Function"></a>3) Function<t, r=""></t,></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Function接口定义了apply方法，接受泛型T对象，返回泛型R对象。适用于map方法中。</p><h5 id="4-其他函数式接口"><a href="#4-其他函数式接口" class="headerlink" title="4) 其他函数式接口"></a>4) 其他函数式接口</h5><table><thead><tr><th>函数式接口</th><th>抽象方法</th></tr></thead><tbody><tr><td>BiConsumer&lt;T, U&gt;</td><td>void accept(T t, U u)</td></tr><tr><td>BiFunction&lt;T, U, R&gt;</td><td>R apply(T t, U u)</td></tr><tr><td>BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt;</td><td>T apply(T t1, T t2)</td></tr><tr><td>BiPredicate&lt;T, U&gt;</td><td>boolean test(T t, U u)</td></tr><tr><td>Supplier&lt;T&gt;</td><td>T get()</td></tr><tr><td>UnaryOperator&lt;T&gt; extends Function<t, t=""></t,></td><td>T apply(T t)</td></tr></tbody></table><h5 id="5-原始类型特化"><a href="#5-原始类型特化" class="headerlink" title="5) 原始类型特化"></a>5) 原始类型特化</h5><p>上述函数式接口的抽象方法都使用了泛型，泛型只能绑定引用类型，那么在输入输出是原始类型时会进行自动装箱，影响性能。 java.util.function中提供了专门的函数式接口避免装箱操作。<br>比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntPredicate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>    <p>如何使用它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IntPredicate evenNumbers = (<span class="keyword">int</span> i) -&gt; i% <span class="number">2</span> == <span class="number">0</span>;</div><div class="line">evenNumbers.test(<span class="number">1000</span>);</div></pre></td></tr></table></figure><br>使用IntPredicate不会对1000装箱，如果用Predicate&lt;Integer&gt;会把1000装到Integer对象中。<br>之前提到的函数式接口都有很多对应的类型特化接口，具体可在java.util.function包中查看。</p><hr><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用可以看做仅仅调用特定方法的Lambda的一种快捷写法，语法糖。<br>构建方法引用：</p><ul><li>指向静态方法的方法引用：例如Integer的parseInt方法，可以写作Integer:parseInt</li><li>指向任意类型实例方法的方法引用：例如String的length方法，写作String::length</li><li>指向现有对象的实例方法的方法引用：与第二种的区别是第二种是在引用一个对象的方法，而这个对象本身是Lambda的一个参数，第三种方法引用指在Lambda中调用一个已存在的外部对象的方法</li></ul><p><img src="/img/method.png" alt="方法引用"></p><hr><h4 id="复合Lambda表达式"><a href="#复合Lambda表达式" class="headerlink" title="复合Lambda表达式"></a>复合Lambda表达式</h4><p>多个简单的Lambda表达式可以复合成复杂的表达式，比如让两个Predicate做or操作，或者一个Function的输出作为另一个Function的输入。但是函数式接口只有一个抽象方法，实现复合操作的是前面提到的默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(other);</div><div class="line">    <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (t) -&gt; !test(t);&#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(other);</div><div class="line">    <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</div><div class="line">    &#125;    </div><div class="line">&#125;    </div></pre></td></tr></table></figure><p>Predicate接口除了唯一抽象方法外，还有三个默认方法，negate，and和or，可以重用已有的Predicate来创建更复杂的谓词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//苹果是红的</span></div><div class="line">Predicate&lt;Apple&gt; redApple = apple -&gt; <span class="string">"red"</span>.equals(apple.getColor());  </div><div class="line"><span class="comment">//苹果不是红的</span></div><div class="line">Predicate&lt;Apple&gt; notRedApple = redApple.negate();  </div><div class="line"><span class="comment">//苹果是红色又比100克重           </span></div><div class="line">Predicate&lt;Apple&gt; redAndHeavyApple = redApple.and(apple -&gt; apple.getWeight() &gt; <span class="number">100</span>);</div><div class="line"><span class="comment">//苹果是比100克重的红苹果，或者是绿苹果  </span></div><div class="line">Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = </div><div class="line">    redApple.and(apple -&gt; apple.getWeight() &gt; <span class="number">100</span>)</div><div class="line">            .or(apple -&gt; <span class="string">"Green"</span>.equals(apple.getColor()));</div></pre></td></tr></table></figure><p>一个复合Function的例子：</p><p><img src="/img/function.png" alt="复合Function"></p><p>Function接口提供了andThen和compose两个默认方法，andThen相当于 multiply(add(x))，compose相当于 add(multiply(x))。<br>所以上面程序的结果是：4和3。<br>很多函数式接口都有默认方法来结合Lambda表达式复合成更复杂的表达式。</p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Lambda表达式可以理解为一种匿名函数，只有在接受函数式接口的地方才可以使用lambda表达式，它允许直接内联，为函数式接口的抽象方法提供实现，<font color="blue">并且将整个表达式作为函数式接口的一个实例。</font></p><blockquote><p>参考：<br>《Java 8函数式编程》– Richard Warburton<br>《Java 8 in Action》– Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;p&gt;从一个例子开始：用Lambda实现一个比较器&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="Java" scheme="http://captainhong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://captainhong.com/tags/Java/"/>
    
      <category term="Java 8" scheme="http://captainhong.com/tags/Java-8/"/>
    
      <category term="Lambda" scheme="http://captainhong.com/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>First Move</title>
    <link href="http://captainhong.com/2017/10/15/First-Move/"/>
    <id>http://captainhong.com/2017/10/15/First-Move/</id>
    <published>2017-10-15T12:57:20.000Z</published>
    <updated>2017-10-16T16:59:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“你没有什么话想说吗？”  — “有啊”<br>“为什么不说？” — “懒得说”<br>“那就写下来”</p></blockquote><h4 id="为什么做这个博客"><a href="#为什么做这个博客" class="headerlink" title="为什么做这个博客"></a>为什么做这个博客</h4><p>不知不觉工作了快五个月了，好像每天都有汹涌的信息和新鲜事灌进脑子里，密度远远超过了大学里。我一直在被动地接受新知识的冲击，继而渐渐感到不安。我不知道这些东西在哪，我不知道我有没有抓住他们。当我看到的越多，也就越知道我没看到的更多。</p><p>最近似乎独处的时间很多，其实也算不上独处，毕竟每天有超过十个小时窝在公司的椅子里。但是一天下来，好像也没怎么张过嘴。我已经慢慢学不会主动找人说话了，似乎习惯了一个人做事，也乐得清静。这样的生活久了，也就明白了我要依靠的只有自己罢了。</p><p>前段时间看了小朋友演的红楼梦，想起我曾经最迷的书就是这本。但是我现在连十二钗都记不全了。如此想来我用了两个暑假看了两遍，好像都在浪费时间了。心里觉得不甘，于是就又买了一套，当看到封面的时候，莫名觉得欣喜又感动，好像又看到了那个夏天，不写暑假作业，偷偷看“杂书”的我。</p><p>这些算不上什么理由，也毫无逻辑。我本来也不擅长写东西，不会引经据典，条理不清晰，没有论据论点。那到底为什么要搭这个博客呢？大概是想发现些问题，积累点知识，以后不至于失业吧；大概是一个人呆的时间久了，想做点有意思的事不至于太寂寞吧；大概是想记录下时光，给以后或许会迷茫的自己吧。可能这些原因都有，也可能都不是，我唯一真切地记得的是，昨天晚上躺在床上，脑子里有声音问我有没有什么话想说，突然发现自己也有很多想法要表达。那就做个博客吧。我看了看手机，十二点半，嗯，还早着。于是就一晚上都没睡。</p><hr><h4 id="要记录些什么"><a href="#要记录些什么" class="headerlink" title="要记录些什么"></a>要记录些什么</h4><p>我想，这应该会是个披着技术外衣的生活类博客吧。我给这个博客定的title是dabbler，牛津词典翻译成浅尝者，说白了就是半吊子。我觉得半吊子似乎是对自己很好的诠释。我好像还没有大牛们用技术推动世界的宏伟理想，所以应该会花很多时间来闲扯淡。</p><p>当然，不管怎样，至少他应该要穿着那件外衣的。不管工作中还是私下里，遇到的技术问题都值得记下来，看过的书也有必要做些笔记。但是只谈技术未免太严肃，就好像是一个从不洗头不洗澡对着电脑敲一天代码的死宅一样。如果有一天看了哪本小说，可能会记下里面几句话；如果看了哪部动漫，可能会交流二次元文化；如果出去旅游，可能会贴几张照片；如果有一天我遇到另一个人，那可能就有两个人写博客了。</p><p>不管怎样，我希望记录的东西不止有意义，有价值，更要有趣。至少对我来说是有趣的。以后有一天看到今天写的东西，还会笑着想那时候我可真蠢啊。</p><hr><h4 id="First-Move"><a href="#First-Move" class="headerlink" title="First Move"></a>First Move</h4><p>这一篇就暂告一段落了。在写这几百个字的过程中，也算是重新认识自己，我的文笔是真的差。<br>First move是标题，也是结尾，第一篇算是个契机，第一步也不只写篇博客这么肤浅。历史的车轮滚滚向前，哪有时间停滞不前。</p><blockquote><p>竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。</p></blockquote><p>煮碗鸡汤喝，明天又是星期一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;“你没有什么话想说吗？”  — “有啊”&lt;br&gt;“为什么不说？” — “懒得说”&lt;br&gt;“那就写下来”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;为什么做这个博客&quot;&gt;&lt;a href=&quot;#为什么做这个博客&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="随笔" scheme="http://captainhong.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://captainhong.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="http://captainhong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
