<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dabbler</title>
  
  <subtitle>你来人间一趟，你要看看太阳</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://captainhong.com/"/>
  <updated>2017-10-16T16:59:16.000Z</updated>
  <id>http://captainhong.com/</id>
  
  <author>
    <name>Captain</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 8 - Lambda</title>
    <link href="http://captainhong.com/2017/10/16/Java-8-Lambda/"/>
    <id>http://captainhong.com/2017/10/16/Java-8-Lambda/</id>
    <published>2017-10-16T11:49:37.000Z</published>
    <updated>2017-10-16T16:59:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>从一个例子开始：用Lambda实现一个比较器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Apple&gt; byWeight = </div><div class="line">   (Apple apple1, Apple apple2) -&gt; apple1.getWeight().compareTo(apple2.getWeight());</div></pre></td></tr></table></figure><p>Lambda表达式有三个部分：</p><ul><li>参数列表：两个Apple</li><li>箭头：箭头把参数列表和Lambda主体分隔开</li><li>Lambda主体：比较两个Apple的重量。表达式就是Lambda的返回值</li></ul><p>Lambda表达式的基本语法有两种：</p><ul><li>(parameters) -&gt; expression</li><li>(parameters) -&gt; {statements;}</li></ul><p>注：expression隐含了return，如果想显示返回语句需要使用第二种statements语法。</p><hr><h4 id="何时使用Lambda"><a href="#何时使用Lambda" class="headerlink" title="何时使用Lambda"></a>何时使用Lambda</h4><p>我们可以在函数式接口上使用Lambda表达式。<br>函数式接口：只定义一个抽象方法的接口(比如例子中的Comparator接口只定义了一个compare()抽象方法)。<br>注：<font color="blue">Java 8中新增了默认方法，即在类没有对方法进行实现时，主体为方法提供默认实现的方法。</font>不管有多少默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。</p><hr><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口很有用，因为抽象方法的签名可以描述Lambda表达式的签名，函数式接口的抽象方法签名称为函数描述符。<br>java.util.function包中定义了一些常用的函数式接口：<br>(注：@FunctionalInterface 注解用于表示该接口会设计成一个函数式接口。接口代码省略了默认方法)。</p><h5 id="1）Predicate"><a href="#1）Predicate" class="headerlink" title="1）Predicate"></a>1）Predicate<t></t></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Predicate接口定义了一个test抽象方法，接受泛型T对象，返回一个boolean。适用于filter中。</p><h5 id="2）Consumer"><a href="#2）Consumer" class="headerlink" title="2）Consumer"></a>2）Consumer<t></t></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;    </div></pre></td></tr></table></figure><p>Consumer定义了一个accept抽象方法，接受泛型T对象，没有返回。如果需要访问一个对象并对其执行某些操作就可以使用这个接口。</p><h5 id="3-Function"><a href="#3-Function" class="headerlink" title="3) Function"></a>3) Function<t, r=""></t,></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Function接口定义了apply方法，接受泛型T对象，返回泛型R对象。适用于map方法中。</p><h5 id="4-其他函数式接口"><a href="#4-其他函数式接口" class="headerlink" title="4) 其他函数式接口"></a>4) 其他函数式接口</h5><table><thead><tr><th>函数式接口</th><th>抽象方法</th></tr></thead><tbody><tr><td>BiConsumer&lt;T, U&gt;</td><td>void accept(T t, U u)</td></tr><tr><td>BiFunction&lt;T, U, R&gt;</td><td>R apply(T t, U u)</td></tr><tr><td>BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt;</td><td>T apply(T t1, T t2)</td></tr><tr><td>BiPredicate&lt;T, U&gt;</td><td>boolean test(T t, U u)</td></tr><tr><td>Supplier&lt;T&gt;</td><td>T get()</td></tr><tr><td>UnaryOperator&lt;T&gt; extends Function<t, t=""></t,></td><td>T apply(T t)</td></tr></tbody></table><h5 id="5）原始类型特化"><a href="#5）原始类型特化" class="headerlink" title="5）原始类型特化"></a>5）原始类型特化</h5><p>上述函数式接口的抽象方法都使用了泛型，泛型只能绑定引用类型，那么在输入输出是原始类型时会进行自动装箱，影响性能。 java.util.function中提供了专门的函数式接口避免装箱操作。<br>比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntPredicate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>    <p>如何使用它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IntPredicate evenNumbers = (<span class="keyword">int</span> i) -&gt; i% <span class="number">2</span> == <span class="number">0</span>;</div><div class="line">evenNumbers.test(<span class="number">1000</span>);</div></pre></td></tr></table></figure><br>使用IntPredicate不会对1000装箱，如果用Predicate&lt;Integer&gt;会把1000装到Integer对象中。<br>之前提到的函数式接口都有很多对应的类型特化接口，具体可在java.util.function包中查看。</p><hr><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用可以看做仅仅调用特定方法的Lambda的一种快捷写法，语法糖。<br>构建方法引用：</p><ul><li>指向静态方法的方法引用：例如Integer的parseInt方法，可以写作Integer:parseInt</li><li>指向任意类型实例方法的方法引用：例如String的length方法，写作String::length</li><li>指向现有对象的实例方法的方法引用：与第二种的区别是第二种是在引用一个对象的方法，而这个对象本身是Lambda的一个参数，第三种方法引用指在Lambda中调用一个已存在的外部对象的方法</li></ul><p><img src="/img/method.png" alt="方法引用"></p><hr><h4 id="复合Lambda表达式"><a href="#复合Lambda表达式" class="headerlink" title="复合Lambda表达式"></a>复合Lambda表达式</h4><p>多个简单的Lambda表达式可以复合成复杂的表达式，比如让两个Predicate做or操作，或者一个Function的输出作为另一个Function的输入。但是函数式接口只有一个抽象方法，实现复合操作的是前面提到的默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(other);</div><div class="line">    <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (t) -&gt; !test(t);&#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(other);</div><div class="line">    <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</div><div class="line">    &#125;    </div><div class="line">&#125;    </div></pre></td></tr></table></figure><p>Predicate接口除了唯一抽象方法外，还有三个默认方法，negate，and和or，可以重用已有的Predicate来创建更复杂的谓词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//苹果是红的</span></div><div class="line">Predicate&lt;Apple&gt; redApple = apple -&gt; <span class="string">"red"</span>.equals(apple.getColor());  </div><div class="line"><span class="comment">//苹果不是红的</span></div><div class="line">Predicate&lt;Apple&gt; notRedApple = redApple.negate();  </div><div class="line"><span class="comment">//苹果是红色又比100克重           </span></div><div class="line">Predicate&lt;Apple&gt; redAndHeavyApple = redApple.and(apple -&gt; apple.getWeight() &gt; <span class="number">100</span>);</div><div class="line"><span class="comment">//苹果是比100克重的红苹果，或者是绿苹果  </span></div><div class="line">Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = </div><div class="line">    redApple.and(apple -&gt; apple.getWeight() &gt; <span class="number">100</span>)</div><div class="line">            .or(apple -&gt; <span class="string">"Green"</span>.equals(apple.getColor()));</div></pre></td></tr></table></figure><p>一个复合Function的例子：</p><p><img src="/img/function.png" alt="复合Function"></p><p>Function接口提供了andThen和compose两个默认方法，andThen相当于 multiply(add(x))，compose相当于 add(multiply(x))。<br>所以上面程序的结果是：4和3。<br>很多函数式接口都有默认方法来结合Lambda表达式复合成更复杂的表达式。</p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Lambda表达式可以理解为一种匿名函数，只有在接受函数式接口的地方才可以使用lambda表达式，它允许直接内联，为函数式接口的抽象方法提供实现，<font color="blue">并且将整个表达式作为函数式接口的一个实例。</font></p><blockquote><p>参考：<br>《Java 8函数式编程》– Richard Warburton<br>《Java 8 in Action》– Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;p&gt;从一个例子开始：用Lambda实现一个比较器&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="Java" scheme="http://captainhong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://captainhong.com/tags/Java/"/>
    
      <category term="Java 8" scheme="http://captainhong.com/tags/Java-8/"/>
    
      <category term="Lambda" scheme="http://captainhong.com/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>First Move</title>
    <link href="http://captainhong.com/2017/10/15/First-Move/"/>
    <id>http://captainhong.com/2017/10/15/First-Move/</id>
    <published>2017-10-15T12:57:20.000Z</published>
    <updated>2017-10-16T16:59:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“你没有什么话想说吗？”  — “有啊”<br>“为什么不说？” — “懒得说”<br>“那就写下来”</p></blockquote><h4 id="为什么做这个博客"><a href="#为什么做这个博客" class="headerlink" title="为什么做这个博客"></a>为什么做这个博客</h4><p>不知不觉工作了快五个月了，好像每天都有汹涌的信息和新鲜事灌进脑子里，密度远远超过了大学里。我一直在被动地接受新知识的冲击，继而渐渐感到不安。我不知道这些东西在哪，我不知道我有没有抓住他们。当我看到的越多，也就越知道我没看到的更多。</p><p>最近似乎独处的时间很多，其实也算不上独处，毕竟每天有超过十个小时窝在公司的椅子里。但是一天下来，好像也没怎么张过嘴。我已经慢慢学不会主动找人说话了，似乎习惯了一个人做事，也乐得清静。这样的生活久了，也就明白了我要依靠的只有自己罢了。</p><p>前段时间看了小朋友演的红楼梦，想起我曾经最迷的书就是这本。但是我现在连十二钗都记不全了。如此想来我用了两个暑假看了两遍，好像都在浪费时间了。心里觉得不甘，于是就又买了一套，当看到封面的时候，莫名觉得欣喜又感动，好像又看到了那个夏天，不写暑假作业，偷偷看“杂书”的我。</p><p>这些算不上什么理由，也毫无逻辑。我本来也不擅长写东西，不会引经据典，条理不清晰，没有论据论点。那到底为什么要搭这个博客呢？大概是想发现些问题，积累点知识，以后不至于失业吧；大概是一个人呆的时间久了，想做点有意思的事不至于太寂寞吧；大概是想记录下时光，给以后或许会迷茫的自己吧。可能这些原因都有，也可能都不是，我唯一真切地记得的是，昨天晚上躺在床上，脑子里有声音问我有没有什么话想说，突然发现自己也有很多想法要表达。那就做个博客吧。我看了看手机，十二点半，嗯，还早着。于是就一晚上都没睡。</p><hr><h4 id="要记录些什么"><a href="#要记录些什么" class="headerlink" title="要记录些什么"></a>要记录些什么</h4><p>我想，这应该会是个披着技术外衣的生活类博客吧。我给这个博客定的title是dabbler，牛津词典翻译成浅尝者，说白了就是半吊子。我觉得半吊子似乎是对自己很好的诠释。我好像还没有大牛们用技术推动世界的宏伟理想，所以应该会花很多时间来闲扯淡。</p><p>当然，不管怎样，至少他应该要穿着那件外衣的。不管工作中还是私下里，遇到的技术问题都值得记下来，看过的书也有必要做些笔记。但是只谈技术未免太严肃，就好像是一个从不洗头不洗澡对着电脑敲一天代码的死宅一样。如果有一天看了哪本小说，可能会记下里面几句话；如果看了哪部动漫，可能会交流二次元文化；如果出去旅游，可能会贴几张照片；如果有一天我遇到另一个人，那可能就有两个人写博客了。</p><p>不管怎样，我希望记录的东西不止有意义，有价值，更要有趣。至少对我来说是有趣的。以后有一天看到今天写的东西，还会笑着想那时候我可真蠢啊。</p><hr><h4 id="First-Move"><a href="#First-Move" class="headerlink" title="First Move"></a>First Move</h4><p>这一篇就暂告一段落了。在写这几百个字的过程中，也算是重新认识自己，我的文笔是真的差。<br>First move是标题，也是结尾，第一篇算是个契机，第一步也不只写篇博客这么肤浅。历史的车轮滚滚向前，哪有时间停滞不前。</p><blockquote><p>竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。</p></blockquote><p>煮碗鸡汤喝，明天又是星期一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;“你没有什么话想说吗？”  — “有啊”&lt;br&gt;“为什么不说？” — “懒得说”&lt;br&gt;“那就写下来”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;为什么做这个博客&quot;&gt;&lt;a href=&quot;#为什么做这个博客&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="随笔" scheme="http://captainhong.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://captainhong.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="http://captainhong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
