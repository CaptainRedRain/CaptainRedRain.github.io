<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dabbler</title>
  
  <subtitle>你来人间一趟，你要看看太阳</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://captainhong.com/"/>
  <updated>2017-10-17T19:17:36.000Z</updated>
  <id>http://captainhong.com/</id>
  
  <author>
    <name>Captain</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于《龙族》</title>
    <link href="http://captainhong.com/2017/10/18/%E5%85%B3%E4%BA%8E%E3%80%8A%E9%BE%99%E6%97%8F%E3%80%8B/"/>
    <id>http://captainhong.com/2017/10/18/关于《龙族》/</id>
    <published>2017-10-17T19:08:17.000Z</published>
    <updated>2017-10-17T19:17:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>听说《上海堡垒》要拍电影了。想来江南是要忙着做编剧去了，不知道龙五又要等到什么时候。关于《龙族》，不得不吐槽作者。我还从来没见过一个作家能像南大这样拖稿的，当然，他主业太多，没时间搞写作的副业。</p><p>从大一上学期开始追海贼，下学期开始追妖尾，追龙族是从高二开始的。今年妖尾完结了，龙五还遥遥无期。高中的时候课余时间少，一周只有半天假，还是磕磕绊绊的追了两部。因为看了龙族，后来顺带也看了《此间的少年》和《九州缥缈录》，但是都没能像龙族这样让我钟意。</p><p>龙族并不是第一眼就讨人喜欢的，主角又衰又懦弱，小心翼翼的喜欢也被人当众嘲弄，读起来并不酣畅淋漓。但正是这时候，诺诺推门而入，目光如刀，牵起这个衰仔，高傲地从人群中带走他。</p><blockquote><p>人一生里总有几次觉得自己看见了天堂之门洞开，路明非等了十八年，在他最衰的那一刻，门开了。</p></blockquote><p>我承认最开始吸引我看下去的是浑身都是棱角，骄傲又耀眼的诺诺，不是路明非。</p><p>看龙族的女生可能有超过三分之一喜欢凯撒，多金又帅气，霸道又温柔，这样的人却偏偏又专一，没有一丝破绽。应该还有超过三分之一喜欢楚子航，沉默，冷静，仗义，而且强得离谱。剩下那些大概也没多少喜欢路明非，因为他确实从头衰到脚。<br>然而路明非才是大部分人的样子。有想做的事，想保护的人，但是他实在太衰了，只能窝在角落里，目光呆滞，盯着聚光灯下的凯撒牵着诺诺的手，还要嘟囔着学姐你要幸福这样的烂话。</p><blockquote><p>最孤单的人分两种，一种恨不得全世界都跟他一样倒霉，一种则希望别人能幸福，因为看到幸福的人，他也略略觉得温暖。</p></blockquote><p>他总是这样衰，衰到全然忘记是自己卖掉灵魂斩了龙王，是自己在三峡的江底豁出了命救下了诺诺。他做了想做的事，也保护了想保护的人，聚光灯下的依然不是他，所以他认了命，以为自己只能是个衰人。<br>我一直在等着路明非撕掉懦弱的面具，穿越荒原，竖起战旗，哪怕失去灵魂，背叛世界，也不要耷拉着脑袋，满嘴烂话。但是直到第四部，他都还在有气无力地耍着贫嘴。</p><p>龙族是本很难定义的小说。它看起来好像是个中二的屠龙故事，又好像是衰仔的自我救赎。我不知道江南最想表达什么，在我看来，这更像是一群孤独者的狂欢。<br>龙族里的每一个主角几乎都是孤独的。</p><p>凯撒似乎是最不应该孤独的。他几乎拥有一切，生来就是领袖，注定是屠龙的英雄，于是便也没有人在乎其实他也只是个破小孩。所以当他遇到诺诺，好像从井口照下一道光，人生中除了屠龙又多了其他寄托。凯撒这样的人，愿意满世界地追着一个女孩跑，也就不难理解了。他那么孤独，如果没有诺诺，就只有自己一个人了。</p><p>楚子航则不同，他是一眼就看的出来的孤独。他的孤独更多来自愧疚。在雨中的高架桥上，嬉皮笑脸一事无成的老爸，挥舞着太刀淹没在死侍中，他开着迈巴赫惊恐地逃走。从那天起他再也没有畏惧过，即使一个人面对龙王。对于楚子航，最大的荣耀应该是和父亲一起战死吧。后来他遇到了夏弥，楚子航居然会说像路明非一样的烂话了，可惜他唯一喜欢的女孩是一条龙。他应该在孤独中再也逃不出来了。</p><p>昂热的孤独隐藏的很好，却也很明显。他的孤独源自仇恨，表现在屠龙的狂热上。这个一百多岁的老头，还每天混迹在上流酒宴，搂着法国名模谈笑风生。但是当他面对真正的龙类的时候，似乎变了一个人。不再是款款而谈的绅士，也不是万人敬仰的领袖，更像杀红眼的亡命之徒。只有那些跟他一样老的掉了牙的人才知道，眼看着同伴死在自己面前，昂热是怎么坚持活到现在的。他孤独到靠着仇恨支撑自己生的希望。</p><p>而路明非，大概是孤独的终点了。明知道什么事都不可能，还非要揣着希望，明明想为什么人把命都赌上，可是连下注的理由都没有，这大概就是路明非的孤独。</p><blockquote><p>你最爱的人，你为他做了很多事，但他不知道，因为你觉得做这些事都是应该的，你忘记跟他说了。</p></blockquote><p>他的孤独，是从不被需要，不管他做了什么。没有人觉得他多重要，没有人关心他做了什么，渐渐连他自己都觉得自己是多余的。唯一关心他的人，是一心想买断他灵魂的路鸣泽。这是一个死结。只有他卖掉灵魂歇斯底里的时候，才觉得自己是被需要的，可是当他真的卖光灵魂也许就再也走不出孤独了。不管是人还是龙，路明非都注定踽踽独行。</p><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;听说《上海堡垒》要拍电影了。想来江南是要忙着做编剧去了，不知道龙五又要等到什么时候。关于《龙族》，不得不吐槽作者。我还从来没见过一个作家能像南大这样拖稿的，当然，他主业太多，没时间搞写作的副业。&lt;/p&gt;
&lt;p&gt;从大一上学期开始追海贼，下学期开始追妖尾，追龙族是从高二开始的。
      
    
    </summary>
    
      <category term="小说" scheme="http://captainhong.com/categories/%E5%B0%8F%E8%AF%B4/"/>
    
    
      <category term="小说" scheme="http://captainhong.com/tags/%E5%B0%8F%E8%AF%B4/"/>
    
      <category term="龙族" scheme="http://captainhong.com/tags/%E9%BE%99%E6%97%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 - Stream</title>
    <link href="http://captainhong.com/2017/10/17/Java-8-Stream/"/>
    <id>http://captainhong.com/2017/10/17/Java-8-Stream/</id>
    <published>2017-10-17T14:02:49.000Z</published>
    <updated>2017-10-17T16:01:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h4><p>流允许以声明式方式处理数据集合，可以姑且把它们看成遍历数据集的高级迭代器。此外流可以透明地并行处理。</p><h5 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h5><p>优点</p><ul><li>声明性 — 更简洁，更易读</li><li>可复合 — 更灵活</li><li>可并行 — 性能更好</li></ul><h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h5><p>流操作有两个重要的特点</p><ul><li>流水线 — 很多流操作本身会返回一个流，这样多个操作就可以链接起来形成流水线。</li><li>内部迭代 — 流的迭代在背后进行，与显式使用迭代器不同。</li></ul><h5 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h5><p>集合和流的区别在于什么时候计算。集合中的每个元素都要先算出来才添加到集合中，流则是在概念上固定的数据结构，其元素是按需计算的。这个思想是用户仅仅从流中提取需要的值。从另一个角度看流就像延迟创建的集合。</p><h5 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h5><p>流与迭代器类似，只能遍历一次，遍历完这个流就已经被消费掉了。</p><h5 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h5><p>流操作可以分为两类，中间操作和终端操作:</p><ul><li>中间操作指可以连接起来的流操作：如filter，sorted，map和limit等，除非流水线触发终端操作，否则中间操作不会执行任何结果。</li><li>终端操作可以从流的流水线生成结果，如forEach，collect。</li></ul><h5 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h5><p>使用流一般包括三件事：</p><ul><li>一个数据源（如集合）来执行一个操作</li><li>一个中间操作链，形成流水线</li><li>一个终端操作，执行流水线并生成结果</li></ul><h4 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h4><h5 id="1-筛选和切片"><a href="#1-筛选和切片" class="headerlink" title="1. 筛选和切片"></a>1. 筛选和切片</h5><p>下面列举几个常见的流<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用谓词筛选</span></div><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</div><div class="line"><span class="comment">//筛选各异的元素</span></div><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">distinct</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">//截断流，返回不超过给定长度的流</span></div><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</div><div class="line"><span class="comment">//返回扔掉前n个元素的流，如果流中元素不足n个则返回空流</span></div><div class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</div></pre></td></tr></table></figure><br>下面代码筛选出苹果中重于100克的第4和第5个苹果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;Apple&gt; bigAppleList = appleList.stream().filter(apple -&gt; apple.getWeight() &gt; <span class="number">100</span>)</div><div class="line">                                    .limit(<span class="number">5</span>).skip(<span class="number">3</span>).collect(toList());</div></pre></td></tr></table></figure></p><h5 id="2-映射"><a href="#2-映射" class="headerlink" title="2. 映射"></a>2. 映射</h5><p>下面列举几个常见的流<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//map方法接受function作为参数，并被应用在每个元素上映射成新的元素</span></div><div class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</div><div class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span></span>;</div></pre></td></tr></table></figure><br>从flatMap的函数定义来看，它接受一个function，而这个function的第二个参数是stream，也就是说函数描述符为T→Stream<r>， Arrays中有stream()方法可以将数组转化成流。<br><img src="/img/stream1.png" alt="2-1"><br>等同于：<br><img src="/img/stream2.png" alt="2-2"><br>map被应用到数组中的两个字符串”Hello”和”World”中，映射成两个String数组，而我们想要的是Stream&lt;String&gt;而不是Stream&lt;String[]&gt;，如果用map来映射将会得到流的列表，所以需要用flatMap把各个数组映射成一个流。<br>简单来说，flatMap方法会把一个流中的每个值都转换成另一个流，然后把所有流连接起来成为一个流。</r></p><h5 id="3-查找和匹配"><a href="#3-查找和匹配" class="headerlink" title="3. 查找和匹配"></a>3. 查找和匹配</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//流中是否有一个元素匹配给定的谓词</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</div><div class="line"><span class="comment">//流中的元素是否都能匹配给定的谓词</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</div><div class="line"><span class="comment">//流中没有元素与给定的谓词匹配</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</div><div class="line"><span class="comment">//返回流中任意元素。流水线将会利用短路找到结果立即结束</span></div><div class="line"><span class="function">Optional&lt;T&gt; <span class="title">findAny</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">//找到第一个元素。在并行上限制较多，如果不关心返回元素是哪一个建议使用findAny()，因为它在并行流上限制较少</span></div><div class="line"><span class="function">Optional&lt;T&gt; <span class="title">findFirst</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure><h5 id="4-归约"><a href="#4-归约" class="headerlink" title="4. 归约"></a>4. 归约</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个参数为初始值</span></div><div class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</div><div class="line"><span class="comment">// 无初始值,考虑流中没有任何元素的情况，reduce无法返回和，所以结果包裹在Optional对象里以表明和可能不存在</span></div><div class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</div></pre></td></tr></table></figure><p>想计算整型数组的和：<br><img src="/img/stream3.png" alt="&quot;2-3&quot;"><br>结果是20。<br>reduce() 也可以用来求最大值或者最小值。</p><h4 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h4><p>和函数式接口的原始类型特化一样，为避免装箱拆箱成本，Stream API提供了数值流。<br>Java 8引入三个原始类型特化流：IntStream, DoubleStream和LongStream, 分别将流中的元素特化为int，double和long，从而避免了reduce时暗含的拆箱成本。每个接口都带来了进行常用数值归约的新方法，例如count(), max(), min(), average()和sum()等。<br>映射到数值流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</div><div class="line"><span class="function">LongStream <span class="title">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</div><div class="line"><span class="function">DoubleStream <span class="title">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span>;</div></pre></td></tr></table></figure><br>转换回对象流：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Stream&lt;Integer&gt; <span class="title">boxed</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure><br>使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IntStream intStream = appleList.stream().mapToInt(Apple::getWeight);   <span class="comment">//转换成数值流</span></div><div class="line">Stream&lt;Integer&gt; stream = intStream.boxed();   <span class="comment">//转换成Stream</span></div></pre></td></tr></table></figure><br>数值流中有很多实用的方法，如求数值范围，IntStream evenNumbers = IntStream.rangeClosed(1, 100);</p><h4 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h4><p>除了从集合生成流，还有其他几种生成流的方式</p><h5 id="1-由值构建流"><a href="#1-由值构建流" class="headerlink" title="1. 由值构建流"></a>1. 由值构建流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"zhao"</span>, <span class="string">"hong"</span>, <span class="string">"yu"</span>);</div><div class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</div></pre></td></tr></table></figure><h5 id="2-由数组构造流"><a href="#2-由数组构造流" class="headerlink" title="2. 由数组构造流"></a>2. 由数组构造流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] name = &#123;<span class="string">"zhao"</span>, <span class="string">"hong"</span>, <span class="string">"yu"</span>&#125;;</div><div class="line">Stream&lt;String&gt; stream = Arrays.stream(name);</div></pre></td></tr></table></figure><h5 id="3-由文件生成流"><a href="#3-由文件生成流" class="headerlink" title="3. 由文件生成流"></a>3. 由文件生成流</h5><p>java.nio.file.Files中有很多静态方法可以返回一个流，例如Files.lines会返回指定文件中各行构成的字符串流。使用的不多，先不介绍。</p><h5 id="4-由函数生成流"><a href="#4-由函数生成流" class="headerlink" title="4. 由函数生成流"></a>4. 由函数生成流</h5><p>Stream API 提供了两个静态方法从函数生成流：Stream.iterate和Stream.generate。这两个操作可以创建无限流。一般会用limit来加以限制<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n+<span class="number">2</span>).limit(<span class="number">100</span>).forEach(System.out::println);</div></pre></td></tr></table></figure><br>生成结果是从0开始公差为2的等差数列的前100项。</p><h4 id="用流收集数据"><a href="#用流收集数据" class="headerlink" title="用流收集数据"></a>用流收集数据</h4><p>终端操作除了count, findFirst, reduce, forEach等，最常用的是collect操作。collect接受Collector作为参数<br>Collectors类提供了很多常用的静态工厂方法生成Collector：<br><img src="/img/stream4.png" alt="4-1"></p><blockquote><p>参考：<br>《Java 8函数式编程》– Richard Warburton<br>《Java 8 in Action》– Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;流的概念&quot;&gt;&lt;a href=&quot;#流的概念&quot; class=&quot;headerlink&quot; title=&quot;流的概念&quot;&gt;&lt;/a&gt;流的概念&lt;/h4&gt;&lt;p&gt;流允许以声明式方式处理数据集合，可以姑且把它们看成遍历数据集的高级迭代器。此外流可以透明地并行处理。&lt;/p&gt;
&lt;h5 id=
      
    
    </summary>
    
      <category term="Java" scheme="http://captainhong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://captainhong.com/tags/Java/"/>
    
      <category term="Java 8" scheme="http://captainhong.com/tags/Java-8/"/>
    
      <category term="Stream" scheme="http://captainhong.com/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 - Lambda</title>
    <link href="http://captainhong.com/2017/10/16/Java-8-Lambda/"/>
    <id>http://captainhong.com/2017/10/16/Java-8-Lambda/</id>
    <published>2017-10-16T11:49:37.000Z</published>
    <updated>2017-10-16T17:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>从一个例子开始：用Lambda实现一个比较器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Apple&gt; byWeight = </div><div class="line">   (Apple apple1, Apple apple2) -&gt; apple1.getWeight().compareTo(apple2.getWeight());</div></pre></td></tr></table></figure><p>Lambda表达式有三个部分：</p><ul><li>参数列表：两个Apple</li><li>箭头：箭头把参数列表和Lambda主体分隔开</li><li>Lambda主体：比较两个Apple的重量。表达式就是Lambda的返回值</li></ul><p>Lambda表达式的基本语法有两种：</p><ul><li>(parameters) -&gt; expression</li><li>(parameters) -&gt; {statements;}</li></ul><p>注：expression隐含了return，如果想显示返回语句需要使用第二种statements语法。</p><hr><h4 id="何时使用Lambda"><a href="#何时使用Lambda" class="headerlink" title="何时使用Lambda"></a>何时使用Lambda</h4><p>我们可以在函数式接口上使用Lambda表达式。<br>函数式接口：只定义一个抽象方法的接口(比如例子中的Comparator接口只定义了一个compare()抽象方法)。<br>注：<font color="blue">Java 8中新增了默认方法，即在类没有对方法进行实现时，主体为方法提供默认实现的方法。</font>不管有多少默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。</p><hr><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口很有用，因为抽象方法的签名可以描述Lambda表达式的签名，函数式接口的抽象方法签名称为函数描述符。<br>java.util.function包中定义了一些常用的函数式接口：<br>(注：@FunctionalInterface 注解用于表示该接口会设计成一个函数式接口。接口代码省略了默认方法)。</p><h5 id="1-Predicate"><a href="#1-Predicate" class="headerlink" title="1) Predicate"></a>1) Predicate<t></t></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Predicate接口定义了一个test抽象方法，接受泛型T对象，返回一个boolean。适用于filter中。</p><h5 id="2-Consumer"><a href="#2-Consumer" class="headerlink" title="2) Consumer"></a>2) Consumer<t></t></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;    </div></pre></td></tr></table></figure><p>Consumer定义了一个accept抽象方法，接受泛型T对象，没有返回。如果需要访问一个对象并对其执行某些操作就可以使用这个接口。</p><h5 id="3-Function"><a href="#3-Function" class="headerlink" title="3) Function"></a>3) Function<t, r=""></t,></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Function接口定义了apply方法，接受泛型T对象，返回泛型R对象。适用于map方法中。</p><h5 id="4-其他函数式接口"><a href="#4-其他函数式接口" class="headerlink" title="4) 其他函数式接口"></a>4) 其他函数式接口</h5><table><thead><tr><th>函数式接口</th><th>抽象方法</th></tr></thead><tbody><tr><td>BiConsumer&lt;T, U&gt;</td><td>void accept(T t, U u)</td></tr><tr><td>BiFunction&lt;T, U, R&gt;</td><td>R apply(T t, U u)</td></tr><tr><td>BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt;</td><td>T apply(T t1, T t2)</td></tr><tr><td>BiPredicate&lt;T, U&gt;</td><td>boolean test(T t, U u)</td></tr><tr><td>Supplier&lt;T&gt;</td><td>T get()</td></tr><tr><td>UnaryOperator&lt;T&gt; extends Function<t, t=""></t,></td><td>T apply(T t)</td></tr></tbody></table><h5 id="5-原始类型特化"><a href="#5-原始类型特化" class="headerlink" title="5) 原始类型特化"></a>5) 原始类型特化</h5><p>上述函数式接口的抽象方法都使用了泛型，泛型只能绑定引用类型，那么在输入输出是原始类型时会进行自动装箱，影响性能。 java.util.function中提供了专门的函数式接口避免装箱操作。<br>比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntPredicate</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>    <p>如何使用它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IntPredicate evenNumbers = (<span class="keyword">int</span> i) -&gt; i% <span class="number">2</span> == <span class="number">0</span>;</div><div class="line">evenNumbers.test(<span class="number">1000</span>);</div></pre></td></tr></table></figure><br>使用IntPredicate不会对1000装箱，如果用Predicate&lt;Integer&gt;会把1000装到Integer对象中。<br>之前提到的函数式接口都有很多对应的类型特化接口，具体可在java.util.function包中查看。</p><hr><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用可以看做仅仅调用特定方法的Lambda的一种快捷写法，语法糖。<br>构建方法引用：</p><ul><li>指向静态方法的方法引用：例如Integer的parseInt方法，可以写作Integer:parseInt</li><li>指向任意类型实例方法的方法引用：例如String的length方法，写作String::length</li><li>指向现有对象的实例方法的方法引用：与第二种的区别是第二种是在引用一个对象的方法，而这个对象本身是Lambda的一个参数，第三种方法引用指在Lambda中调用一个已存在的外部对象的方法</li></ul><p><img src="/img/method.png" alt="方法引用"></p><hr><h4 id="复合Lambda表达式"><a href="#复合Lambda表达式" class="headerlink" title="复合Lambda表达式"></a>复合Lambda表达式</h4><p>多个简单的Lambda表达式可以复合成复杂的表达式，比如让两个Predicate做or操作，或者一个Function的输出作为另一个Function的输入。但是函数式接口只有一个抽象方法，实现复合操作的是前面提到的默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(other);</div><div class="line">    <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (t) -&gt; !test(t);&#125;</div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</div><div class="line">    Objects.requireNonNull(other);</div><div class="line">    <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</div><div class="line">    &#125;    </div><div class="line">&#125;    </div></pre></td></tr></table></figure><p>Predicate接口除了唯一抽象方法外，还有三个默认方法，negate，and和or，可以重用已有的Predicate来创建更复杂的谓词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//苹果是红的</span></div><div class="line">Predicate&lt;Apple&gt; redApple = apple -&gt; <span class="string">"red"</span>.equals(apple.getColor());  </div><div class="line"><span class="comment">//苹果不是红的</span></div><div class="line">Predicate&lt;Apple&gt; notRedApple = redApple.negate();  </div><div class="line"><span class="comment">//苹果是红色又比100克重           </span></div><div class="line">Predicate&lt;Apple&gt; redAndHeavyApple = redApple.and(apple -&gt; apple.getWeight() &gt; <span class="number">100</span>);</div><div class="line"><span class="comment">//苹果是比100克重的红苹果，或者是绿苹果  </span></div><div class="line">Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = </div><div class="line">    redApple.and(apple -&gt; apple.getWeight() &gt; <span class="number">100</span>)</div><div class="line">            .or(apple -&gt; <span class="string">"Green"</span>.equals(apple.getColor()));</div></pre></td></tr></table></figure><p>一个复合Function的例子：</p><p><img src="/img/function.png" alt="复合Function"></p><p>Function接口提供了andThen和compose两个默认方法，andThen相当于 multiply(add(x))，compose相当于 add(multiply(x))。<br>所以上面程序的结果是：4和3。<br>很多函数式接口都有默认方法来结合Lambda表达式复合成更复杂的表达式。</p><hr><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Lambda表达式可以理解为一种匿名函数，只有在接受函数式接口的地方才可以使用lambda表达式，它允许直接内联，为函数式接口的抽象方法提供实现，<font color="blue">并且将整个表达式作为函数式接口的一个实例。</font></p><blockquote><p>参考：<br>《Java 8函数式编程》– Richard Warburton<br>《Java 8 in Action》– Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;p&gt;从一个例子开始：用Lambda实现一个比较器&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="Java" scheme="http://captainhong.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://captainhong.com/tags/Java/"/>
    
      <category term="Java 8" scheme="http://captainhong.com/tags/Java-8/"/>
    
      <category term="Lambda" scheme="http://captainhong.com/tags/Lambda/"/>
    
  </entry>
  
  <entry>
    <title>First Move</title>
    <link href="http://captainhong.com/2017/10/15/First-Move/"/>
    <id>http://captainhong.com/2017/10/15/First-Move/</id>
    <published>2017-10-15T12:57:20.000Z</published>
    <updated>2017-10-16T16:59:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“你没有什么话想说吗？”  — “有啊”<br>“为什么不说？” — “懒得说”<br>“那就写下来”</p></blockquote><h4 id="为什么做这个博客"><a href="#为什么做这个博客" class="headerlink" title="为什么做这个博客"></a>为什么做这个博客</h4><p>不知不觉工作了快五个月了，好像每天都有汹涌的信息和新鲜事灌进脑子里，密度远远超过了大学里。我一直在被动地接受新知识的冲击，继而渐渐感到不安。我不知道这些东西在哪，我不知道我有没有抓住他们。当我看到的越多，也就越知道我没看到的更多。</p><p>最近似乎独处的时间很多，其实也算不上独处，毕竟每天有超过十个小时窝在公司的椅子里。但是一天下来，好像也没怎么张过嘴。我已经慢慢学不会主动找人说话了，似乎习惯了一个人做事，也乐得清静。这样的生活久了，也就明白了我要依靠的只有自己罢了。</p><p>前段时间看了小朋友演的红楼梦，想起我曾经最迷的书就是这本。但是我现在连十二钗都记不全了。如此想来我用了两个暑假看了两遍，好像都在浪费时间了。心里觉得不甘，于是就又买了一套，当看到封面的时候，莫名觉得欣喜又感动，好像又看到了那个夏天，不写暑假作业，偷偷看“杂书”的我。</p><p>这些算不上什么理由，也毫无逻辑。我本来也不擅长写东西，不会引经据典，条理不清晰，没有论据论点。那到底为什么要搭这个博客呢？大概是想发现些问题，积累点知识，以后不至于失业吧；大概是一个人呆的时间久了，想做点有意思的事不至于太寂寞吧；大概是想记录下时光，给以后或许会迷茫的自己吧。可能这些原因都有，也可能都不是，我唯一真切地记得的是，昨天晚上躺在床上，脑子里有声音问我有没有什么话想说，突然发现自己也有很多想法要表达。那就做个博客吧。我看了看手机，十二点半，嗯，还早着。于是就一晚上都没睡。</p><hr><h4 id="要记录些什么"><a href="#要记录些什么" class="headerlink" title="要记录些什么"></a>要记录些什么</h4><p>我想，这应该会是个披着技术外衣的生活类博客吧。我给这个博客定的title是dabbler，牛津词典翻译成浅尝者，说白了就是半吊子。我觉得半吊子似乎是对自己很好的诠释。我好像还没有大牛们用技术推动世界的宏伟理想，所以应该会花很多时间来闲扯淡。</p><p>当然，不管怎样，至少他应该要穿着那件外衣的。不管工作中还是私下里，遇到的技术问题都值得记下来，看过的书也有必要做些笔记。但是只谈技术未免太严肃，就好像是一个从不洗头不洗澡对着电脑敲一天代码的死宅一样。如果有一天看了哪本小说，可能会记下里面几句话；如果看了哪部动漫，可能会交流二次元文化；如果出去旅游，可能会贴几张照片；如果有一天我遇到另一个人，那可能就有两个人写博客了。</p><p>不管怎样，我希望记录的东西不止有意义，有价值，更要有趣。至少对我来说是有趣的。以后有一天看到今天写的东西，还会笑着想那时候我可真蠢啊。</p><hr><h4 id="First-Move"><a href="#First-Move" class="headerlink" title="First Move"></a>First Move</h4><p>这一篇就暂告一段落了。在写这几百个字的过程中，也算是重新认识自己，我的文笔是真的差。<br>First move是标题，也是结尾，第一篇算是个契机，第一步也不只写篇博客这么肤浅。历史的车轮滚滚向前，哪有时间停滞不前。</p><blockquote><p>竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。</p></blockquote><p>煮碗鸡汤喝，明天又是星期一。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;“你没有什么话想说吗？”  — “有啊”&lt;br&gt;“为什么不说？” — “懒得说”&lt;br&gt;“那就写下来”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;为什么做这个博客&quot;&gt;&lt;a href=&quot;#为什么做这个博客&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="随笔" scheme="http://captainhong.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://captainhong.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="http://captainhong.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
