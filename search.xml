<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 8 - Stream]]></title>
    <url>%2F2017%2F10%2F17%2FJava-8-Stream%2F</url>
    <content type="text"><![CDATA[流的概念流允许以声明式方式处理数据集合，可以姑且把它们看成遍历数据集的高级迭代器。此外流可以透明地并行处理。 1.优点 声明性 — 更简洁，更易读 可复合 — 更灵活 可并行 — 性能更好 2.流操作有两个重要的特点 流水线 — 很多流操作本身会返回一个流，这样多个操作就可以链接起来形成流水线。 内部迭代 — 流的迭代在背后进行，与显式使用迭代器不同。 3.集合和流的区别在于什么时候计算。集合中的每个元素都要先算出来才添加到集合中，流则是在概念上固定的数据结构，其元素是按需计算的。这个思想是用户仅仅从流中提取需要的值。从另一个角度看流就像延迟创建的集合。 4.流与迭代器类似，只能遍历一次，遍历完这个流就已经被消费掉了。 5.流操作可以分为两类，中间操作和终端操作: 中间操作指可以连接起来的流操作：如filter，sorted，map和limit等，除非流水线触发终端操作，否则中间操作不会执行任何结果。 终端操作可以从流的流水线生成结果，如forEach，collect。 6.使用流一般包括三件事： 一个数据源（如集合）来执行一个操作 一个中间操作链，形成流水线 一个终端操作，执行流水线并生成结果 使用流1. 筛选和切片下面列举几个常见的流12345678//用谓词筛选Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);//筛选各异的元素Stream&lt;T&gt; distinct();//截断流，返回不超过给定长度的流Stream&lt;T&gt; limit(long maxSize);//返回扔掉前n个元素的流，如果流中元素不足n个则返回空流Stream&lt;T&gt; skip(long n);下面代码筛选出苹果中重于100克的第4和第5个苹果。12List&lt;Apple&gt; bigAppleList = appleList.stream().filter(apple -&gt; apple.getWeight() &gt; 100) .limit(5).skip(3).collect(toList()); 2. 映射下面列举几个常见的流123//map方法接受function作为参数，并被应用在每个元素上映射成新的元素&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);从flatMap的函数定义来看，它接受一个function，而这个function的第二个参数是stream，也就是说函数描述符为T→Stream， Arrays中有stream()方法可以将数组转化成流。等同于：map被应用到数组中的两个字符串”Hello”和”World”中，映射成两个String数组，而我们想要的是Stream&lt;String&gt;而不是Stream&lt;String[]&gt;，如果用map来映射将会得到流的列表，所以需要用flatMap把各个数组映射成一个流。简单来说，flatMap方法会把一个流中的每个值都转换成另一个流，然后把所有流连接起来成为一个流。 3. 查找和匹配12345678910//流中是否有一个元素匹配给定的谓词boolean anyMatch(Predicate&lt;? super T&gt; predicate);//流中的元素是否都能匹配给定的谓词boolean allMatch(Predicate&lt;? super T&gt; predicate);//流中没有元素与给定的谓词匹配boolean noneMatch(Predicate&lt;? super T&gt; predicate);//返回流中任意元素。流水线将会利用短路找到结果立即结束Optional&lt;T&gt; findAny();//找到第一个元素。在并行上限制较多，如果不关心返回元素是哪一个建议使用findAny()，因为它在并行流上限制较少Optional&lt;T&gt; findFirst(); 4. 归约1234// 第一个参数为初始值T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);// 无初始值,考虑流中没有任何元素的情况，reduce无法返回和，所以结果包裹在Optional对象里以表明和可能不存在Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); 想计算整型数组的和：结果是20。reduce() 也可以用来求最大值或者最小值。 数值流和函数式接口的原始类型特化一样，为避免装箱拆箱成本，Stream API提供了数值流。Java 8引入三个原始类型特化流：IntStream, DoubleStream和LongStream, 分别将流中的元素特化为int，double和long，从而避免了reduce时暗含的拆箱成本。每个接口都带来了进行常用数值归约的新方法，例如count(), max(), min(), average()和sum()等。映射到数值流：123IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);转换回对象流：1Stream&lt;Integer&gt; boxed();使用方法：12IntStream intStream = appleList.stream().mapToInt(Apple::getWeight); //转换成数值流Stream&lt;Integer&gt; stream = intStream.boxed(); //转换成Stream数值流中有很多实用的方法，如求数值范围，IntStream evenNumbers = IntStream.rangeClosed(1, 100); 构建流除了从集合生成流，还有其他几种生成流的方式 1. 由值构建流12Stream&lt;String&gt; stream = Stream.of("zhao", "hong", "yu");Stream&lt;String&gt; emptyStream = Stream.empty(); 2. 由数组构造流12String[] name = &#123;"zhao", "hong", "yu"&#125;;Stream&lt;String&gt; stream = Arrays.stream(name); 3. 由文件生成流java.nio.file.Files中有很多静态方法可以返回一个流，例如Files.lines会返回指定文件中各行构成的字符串流。使用的不多，先不介绍。 4. 由函数生成流Stream API 提供了两个静态方法从函数生成流：Stream.iterate和Stream.generate。这两个操作可以创建无限流。一般会用limit来加以限制1Stream.iterate(0, n -&gt; n+2).limit(100).forEach(System.out::println);生成结果是从0开始公差为2的等差数列的前100项。 用流收集数据终端操作除了count, findFirst, reduce, forEach等，最常用的是collect操作。collect接受Collector作为参数Collectors类提供了很多常用的静态工厂方法生成Collector： 参考：《Java 8函数式编程》– Richard Warburton《Java 8 in Action》– Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 - Lambda]]></title>
    <url>%2F2017%2F10%2F16%2FJava-8-Lambda%2F</url>
    <content type="text"><![CDATA[基本概念从一个例子开始：用Lambda实现一个比较器 12Comparator&lt;Apple&gt; byWeight = (Apple apple1, Apple apple2) -&gt; apple1.getWeight().compareTo(apple2.getWeight()); Lambda表达式有三个部分： 参数列表：两个Apple 箭头：箭头把参数列表和Lambda主体分隔开 Lambda主体：比较两个Apple的重量。表达式就是Lambda的返回值 Lambda表达式的基本语法有两种： (parameters) -&gt; expression (parameters) -&gt; {statements;} 注：expression隐含了return，如果想显示返回语句需要使用第二种statements语法。 何时使用Lambda我们可以在函数式接口上使用Lambda表达式。函数式接口：只定义一个抽象方法的接口(比如例子中的Comparator接口只定义了一个compare()抽象方法)。注：Java 8中新增了默认方法，即在类没有对方法进行实现时，主体为方法提供默认实现的方法。不管有多少默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。 函数式接口函数式接口很有用，因为抽象方法的签名可以描述Lambda表达式的签名，函数式接口的抽象方法签名称为函数描述符。java.util.function包中定义了一些常用的函数式接口：(注：@FunctionalInterface 注解用于表示该接口会设计成一个函数式接口。接口代码省略了默认方法)。 1) Predicate1234@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125; Predicate接口定义了一个test抽象方法，接受泛型T对象，返回一个boolean。适用于filter中。 2) Consumer1234@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125; Consumer定义了一个accept抽象方法，接受泛型T对象，没有返回。如果需要访问一个对象并对其执行某些操作就可以使用这个接口。 3) Function1234@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t);&#125; Function接口定义了apply方法，接受泛型T对象，返回泛型R对象。适用于map方法中。 4) 其他函数式接口 函数式接口 抽象方法 BiConsumer&lt;T, U&gt; void accept(T t, U u) BiFunction&lt;T, U, R&gt; R apply(T t, U u) BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; T apply(T t1, T t2) BiPredicate&lt;T, U&gt; boolean test(T t, U u) Supplier&lt;T&gt; T get() UnaryOperator&lt;T&gt; extends Function T apply(T t) 5) 原始类型特化上述函数式接口的抽象方法都使用了泛型，泛型只能绑定引用类型，那么在输入输出是原始类型时会进行自动装箱，影响性能。 java.util.function中提供了专门的函数式接口避免装箱操作。比如: 1234@FunctionalInterfacepublic interface IntPredicate &#123; boolean test(int value);&#125; 如何使用它：12IntPredicate evenNumbers = (int i) -&gt; i% 2 == 0;evenNumbers.test(1000);使用IntPredicate不会对1000装箱，如果用Predicate&lt;Integer&gt;会把1000装到Integer对象中。之前提到的函数式接口都有很多对应的类型特化接口，具体可在java.util.function包中查看。 方法引用方法引用可以看做仅仅调用特定方法的Lambda的一种快捷写法，语法糖。构建方法引用： 指向静态方法的方法引用：例如Integer的parseInt方法，可以写作Integer:parseInt 指向任意类型实例方法的方法引用：例如String的length方法，写作String::length 指向现有对象的实例方法的方法引用：与第二种的区别是第二种是在引用一个对象的方法，而这个对象本身是Lambda的一个参数，第三种方法引用指在Lambda中调用一个已存在的外部对象的方法 复合Lambda表达式多个简单的Lambda表达式可以复合成复杂的表达式，比如让两个Predicate做or操作，或者一个Function的输出作为另一个Function的输入。但是函数式接口只有一个抽象方法，实现复合操作的是前面提到的默认方法。 123456789101112131415@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); &#125; default Predicate&lt;T&gt; negate() &#123; return (t) -&gt; !test(t);&#125; default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); &#125; &#125; Predicate接口除了唯一抽象方法外，还有三个默认方法，negate，and和or，可以重用已有的Predicate来创建更复杂的谓词。 12345678910//苹果是红的Predicate&lt;Apple&gt; redApple = apple -&gt; "red".equals(apple.getColor()); //苹果不是红的Predicate&lt;Apple&gt; notRedApple = redApple.negate(); //苹果是红色又比100克重 Predicate&lt;Apple&gt; redAndHeavyApple = redApple.and(apple -&gt; apple.getWeight() &gt; 100);//苹果是比100克重的红苹果，或者是绿苹果 Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = redApple.and(apple -&gt; apple.getWeight() &gt; 100) .or(apple -&gt; "Green".equals(apple.getColor())); 一个复合Function的例子： Function接口提供了andThen和compose两个默认方法，andThen相当于 multiply(add(x))，compose相当于 add(multiply(x))。所以上面程序的结果是：4和3。很多函数式接口都有默认方法来结合Lambda表达式复合成更复杂的表达式。 总结Lambda表达式可以理解为一种匿名函数，只有在接受函数式接口的地方才可以使用lambda表达式，它允许直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。 参考：《Java 8函数式编程》– Richard Warburton《Java 8 in Action》– Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Move]]></title>
    <url>%2F2017%2F10%2F15%2FFirst-Move%2F</url>
    <content type="text"><![CDATA[“你没有什么话想说吗？” — “有啊”“为什么不说？” — “懒得说”“那就写下来” 为什么做这个博客不知不觉工作了快五个月了，好像每天都有汹涌的信息和新鲜事灌进脑子里，密度远远超过了大学里。我一直在被动地接受新知识的冲击，继而渐渐感到不安。我不知道这些东西在哪，我不知道我有没有抓住他们。当我看到的越多，也就越知道我没看到的更多。 最近似乎独处的时间很多，其实也算不上独处，毕竟每天有超过十个小时窝在公司的椅子里。但是一天下来，好像也没怎么张过嘴。我已经慢慢学不会主动找人说话了，似乎习惯了一个人做事，也乐得清静。这样的生活久了，也就明白了我要依靠的只有自己罢了。 前段时间看了小朋友演的红楼梦，想起我曾经最迷的书就是这本。但是我现在连十二钗都记不全了。如此想来我用了两个暑假看了两遍，好像都在浪费时间了。心里觉得不甘，于是就又买了一套，当看到封面的时候，莫名觉得欣喜又感动，好像又看到了那个夏天，不写暑假作业，偷偷看“杂书”的我。 这些算不上什么理由，也毫无逻辑。我本来也不擅长写东西，不会引经据典，条理不清晰，没有论据论点。那到底为什么要搭这个博客呢？大概是想发现些问题，积累点知识，以后不至于失业吧；大概是一个人呆的时间久了，想做点有意思的事不至于太寂寞吧；大概是想记录下时光，给以后或许会迷茫的自己吧。可能这些原因都有，也可能都不是，我唯一真切地记得的是，昨天晚上躺在床上，脑子里有声音问我有没有什么话想说，突然发现自己也有很多想法要表达。那就做个博客吧。我看了看手机，十二点半，嗯，还早着。于是就一晚上都没睡。 要记录些什么我想，这应该会是个披着技术外衣的生活类博客吧。我给这个博客定的title是dabbler，牛津词典翻译成浅尝者，说白了就是半吊子。我觉得半吊子似乎是对自己很好的诠释。我好像还没有大牛们用技术推动世界的宏伟理想，所以应该会花很多时间来闲扯淡。 当然，不管怎样，至少他应该要穿着那件外衣的。不管工作中还是私下里，遇到的技术问题都值得记下来，看过的书也有必要做些笔记。但是只谈技术未免太严肃，就好像是一个从不洗头不洗澡对着电脑敲一天代码的死宅一样。如果有一天看了哪本小说，可能会记下里面几句话；如果看了哪部动漫，可能会交流二次元文化；如果出去旅游，可能会贴几张照片；如果有一天我遇到另一个人，那可能就有两个人写博客了。 不管怎样，我希望记录的东西不止有意义，有价值，更要有趣。至少对我来说是有趣的。以后有一天看到今天写的东西，还会笑着想那时候我可真蠢啊。 First Move这一篇就暂告一段落了。在写这几百个字的过程中，也算是重新认识自己，我的文笔是真的差。First move是标题，也是结尾，第一篇算是个契机，第一步也不只写篇博客这么肤浅。历史的车轮滚滚向前，哪有时间停滞不前。 竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。 煮碗鸡汤喝，明天又是星期一。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
