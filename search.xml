<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[I/O模型]]></title>
    <url>%2F2017%2F11%2F27%2FI-O%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[I/O操作过程Linux内核将外部设备看成文件来读，读写操作会调用内核提供的系统命令，对文件的读写会返回文件描述符(file descriptor)，对socket读写会返回socketfd，描述符指向内核中的一个结构体。一个输入操作通常包括两个阶段： 等待数据准备好 从内核向用户进程复制数据 对于一个套接字的输入操作，第一步是等待网络数据到达，复制到内核中的某个缓冲区中。第二步从内核缓冲区复制到应用进程缓冲区。 Unix I/O模型1) 阻塞式IO从进程空间中调用recvfrom，系统调用直到数据包准备好并复制到应用进程缓冲区，或者发生错误时才返回，这期间整段时间都是阻塞的。 2) 非阻塞式IO进程把一个套接字设成非阻塞是通知内核，当请求的IO操作需要把进程投入睡眠才能完成时，不要把本进程投入睡眠，而是直接返回错误。一个应用进程对一个非阻塞描述符循环调用recvfrom时，称为轮询。 3) IO复用IO复用把IO操作的阻塞移到了select/poll/epoll之类的系统调用上。select返回套接字可读时，再调用recvfrom把数据包复制到应用进程缓冲区。IO复用和非阻塞IO相比的好处是可以等待多个描述符就绪。 4) 信号驱动式IO通过sigaction系统调用安装信号处理函数，系统调用立即返回，进程没有被阻塞。当数据包准备好时内核向进程发送信号，进程调用recvfrom把数据从内核复制到用户空间。 5) 异步IO系统函数提供异步机制：告知内核启动某个操作，并在内核完成整个操作(包括把数据从内核复制到用户空间)通知用户进程。调用aio_read时，会给内核传递描述符，缓冲区指针，缓冲区大小等参数，当内核操作完成并产生某个信号时，数据已经被复制到了应用进程缓冲区中。 6) 5种IO模型对比POSIX对于同步和异步的定义：同步IO操作：导致请求进程阻塞，知道IO操作完成。异步IO操作：不导致请求进程阻塞。 前四种IO的模型的区别在于第一阶段，第二阶段真正的IO操作都将阻塞进程。只有第五种IO模型符合POSIX对于异步IO的定义。 Java I/O1) BIO模型BIO服务端通常由一个独立的Acceptor线程负责监听客户端连接，为每一个客户端创建创建新的线程进行链路处理，处理完之后线程销毁。线程数和客户端并发数1：1，无法满足高性能高并发场景。 通过线程池和任务队列可以一定程度改善线程数膨胀的问题，把socket封装成task放到线程池中处理，通过设置线程池的最大线程数和队列大小来控制资源占用。这种模型读写操作都是阻塞的，如果读取故障服务节点导致输入流阻塞，可能导致所有线程都被故障节点阻塞，后续IO将会放到任务队列中，如果采用阻塞队列实现，队列积满后后续入队列的操作会被阻塞，Acceptor线程接收新的客户端连接会被阻塞在队列之后，客户端请求被拒绝，客户端会发生超时。 2) NIO模型JAVA NIO提供了bufferBuffer：NIO通过缓冲区处理数据，读取的时候直接读到缓冲区中，写入的时候写到缓冲区中，访问NIO中的数据都是通过缓冲区完成的。Channel：通道和流的区别是通道是全双工的，流只能是InputStream或者OutputStream的一个子类。Selector：多路复用器，提供选择已就绪任务的能力。Selector不断轮询注册在其上的channel，当某个channel发生读写事件时会被轮询出来，通过SelectionKey获取就绪channel，进行后续IO操作。JDK使用epoll实现Selector，没有最大句柄限制，所以一个线程可以接入成千上万客户端。典型的NIO服务端实现： 打开ServerSocketChannel，绑定ip和端口，创建Selector，把channel注册到selector上，监听SelectionKey.OP_ACCEPT操作。轮询注册到selector上的channel： 12345678910111213141516171819202122232425Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; it = selectedKeys.iterator();while(it.hasNext())&#123; key = it.next(); //处理请求 if(key.isAcceptable())&#123; ServerSocketChannel ssc = key.channel(); SocketChannel sc = ssc.accept(); sc.register(selector, SelectionKey.OP_READ); &#125; if(key.isReadable())&#123; SocketChannel sc = key.channel(); ByteBuffer readBuffer = ...; int readBytes = sc.read(readBuffer); if(readBytes &gt; 0)&#123; //读到字节 doWrite(); &#125; else if(readBytes &lt; 0)&#123; //链路关闭，关闭channel，释放资源 &#125; else&#123; //没有读到，忽略 &#125; &#125; ......&#125; 3) AIO模型NIO 2.0提供了三个新的异步通道：AsynchronousFileChannel —- 用于文件IOAsynchronousSocketChannel —- 用于套接字IOAsynchronousServerSocketChannel —- 用于套接字接受异步连接同时提供了回调式事件处理机制，基本思想是主线程派遣CompletionHandler到独立线程中执行IO操作，然后带着IO操作结果返回主线程，触发它自己的completed或者failed方法(需要重写这两个方法) 12345678910111213public abstract &lt;A&gt; void accept(A attachment, CompletionHandler&lt;AsynchronousSocketChannel,? super A&gt; handler); //AsynchronousServerSocketChannel.java public final &lt;A&gt; void read(ByteBuffer dst, A attachment, CompletionHandler&lt;Integer,? super A&gt; handler); //AsynchronousSocketChannel.java public final &lt;A&gt; void write(ByteBuffer src, A attachment, CompletionHandler&lt;Integer,? super A&gt; handler); //AsynchronousSocketChannel.java public interface CompletionHandler&lt;V,A&gt; &#123; void completed(V result, A attachment); void failed(Throwable exc, A attachment);&#125; NIO 2.0的异步套接字通道是真正的异步非阻塞IO，对应上诉第五种IO模型。它不需要selector对注册的通道进行轮询即可实现异步读写。一个简单的AIO服务端实现：AsyncTimeServerHandler.class 12345AsynchronousServerSocketChannel asynchronousServerSocketChannel;asynchronousServerSocketChannel = AsynchronousServerSocketChannel.open();asynchronousServerSocketChannel.bind(new InetSocketAddress(port)); asynchronousServerSocketChannel.accept(this, new AcceptCompletionHandler()); AcceptCompletionHandler.class 123456789@Overridepublic void completed(AsynchronousSocketChannel result, AsyncTimerServerHandler attachment)&#123; attachment.asynchronousServerSocketChannel.accept(attachment, this); ByteBuffer buffer = ByteBuffer.allocate(1024); result.read(buffer, buffer, new ReadCompletionHandler(result));&#125; @Overridepublic void failed(...)&#123;...&#125; ReadCompletionHandler.class 123456789101112131415161718192021222324252627282930313233AsynchronousSocketChannel channel;public ReadCompletionHandler(AsynchronousSocketChannel channel)&#123; this.channel = channel;&#125; @Overridepublic void completed(Integer result, ByteBuffer attachment)&#123; byte[] body = new Byte[attachment.remaining()]; attachment.get(body); ... String send = ...; doWrite(send)&#125; private void doWrite(String send)&#123; ByteBuffer writeBuffer = ByteBuffer.allocate(1024); byte[] body = send.getBytes(); writeBuffer.put(body); channel.write(writeBuffer, writeBuffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;()&#123; @Override public void completed(Integer result, ByteBuffer attachment)&#123; if(attachment.hasRemaining())&#123; channel.write(buffer, buffer, this); &#125; &#125; @Override public void failed(...)&#123;...&#125; &#125;);&#125; @Overridepublic void failed(...)&#123;...&#125;]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>I/O</tag>
        <tag>Unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的并发]]></title>
    <url>%2F2017%2F11%2F05%2FJava%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Java 5之后，java.util.concurrent包的出现，取代了传统的块结构并发方式（synchronized、volatile等并发关键字的多线程编程方式），这篇主要总结Java的现代并发方式（Java 5之后）。 概念1. Java线程模型java线程模型建立在两个基本概念之上： 共享、默认可见的可变状态 抢占式线程调度 2. 设计理念 安全性与并发类型安全性：安全性指不管同时发生多少操作都能确保对象保持自相一致，如果一个对象系统具备这一特性，那它就是并发类型安全的。并发类型安全的概念跟对象类型安全一样，但用在更复杂的环境下，在这样的环境中，其他现场称在不同CPU内核上同时操作同一对象。 活跃度：在一个活跃的系统中，所有做出尝试的活动最终或者取得进展，或者失败。关键词：最终。（瞬时故障和永久故障是不同的） 性能 可重用性 3. 编写原则 尽可能限制子系统之间的通信，隐藏数据对安全性非常有帮助 尽可能保证子系统内部结构的确定性：即便子系统之间以并发方式交互，子系统内部的设计也应该参照线程和对象的静态知识 4. 系统开销来源 锁与监测 环境切换次数 线程个数 调度 内存局部性 算法设计 组件1. 原子类 java.util.concurrent.atomic包中的类的语义基本上和volatile一样，只是封装在一个API里了，这是非常简单地避免在共享数据上出现竞争危害（又名竞态条件，指一个系统或进程的输出，依赖于不受控制事件的出现顺序和时机）的方法。注：原子类不是从有相似名称的类继承而来的，所以AtomiciInteger不是Integer，AtomicBoolean也不能用做Boolean。 2. 线程锁 java.util.concurrent.locks块结构同步方式(synchronized)的缺点： 锁只有一种类型 对被锁住的对象的所有同步操作都是一样的作用 在同步代码块或方法开始时取得线程锁，结束时释放线程锁 线程或者取得锁，或者阻塞 可提升: 添加不同类型的锁：读/写锁 对锁的阻塞没有限制，即允许一个方法中上锁，另一个方法中解锁 如果线程得不到锁，允许线程后退或继续执行，或者做其他事情：tryLock()方法 允许超时放弃取锁 Locks接口的两个实现类：ReentrantLock, ReentrantReadWriteLock（在需要很多读取线程而很少写入线程时性能更好） 3. CountDownLatch允许线程在通过同步屏障之前做些少量准备工作在构建CountDownLatch实例时要提供一个int值的计数器，还有两个用来控制锁存器的方法，countDown()和await()方法，前者对计数器减一，后者让调用线程在计数器到0之前一直等待（如果计数器已经为0或更小则什么都不做）。 4. ConcurrentHashMapConcurrentHashMap改进了Collections类中提供的synchronizedMap()功能，因为那些方法返回的集合中包含的锁比需要的多。多线程修改hashmap时并不需要把整个结构都锁住，只要锁住即将修改的桶就行。好的并发HashMap实现在读取时不用锁，写入时只需锁住要修改的桶。ConcurrentHashMap提供了原子操作的新方法： putIfAbsent()：如果没有对应键，则把键值对添加到hashmap中 remove()：如果对应键存在，且值也与当前状态相等(equal)，则用原子方式移除 replace()：原子替换 5. CopyOnWriteArrayListCopyOnWriteArrayList 通过增加写时复制语义来实现线程安全性：修改列表的任何操作都会创建一个列表底层数组的新副本 6. QueueBlockingQueue: 在向队列中put()时，如果队列已满，它会让放入线程等待队列腾出空间 在从队列中take()时，如果队列为空，会导致取出线程阻塞 BlockingQueue的两个基本实现：LinkedBlockingQueue和ArrayBlockingQueue。在已知队列大小能确定合适边界时，ArrayBlockingQueue非常高效，而LinkedBlockingQueue在某些情况下会快一点。 TransferQueue：本质上是多了一项transfer()操作的BlockingQueue。如果接收线程处于等待状态，该操作会马上把工作项传给它，否则会阻塞直到取走工作项的线程出现。用限定大小的阻塞队列也能达到这种调控效果，但TransferQueue接口更灵活。此外，用TransferQueue取代BlockingQueue的代码性能表现可能会更好。这是因为编写TransferQueue的实现时已经将现代编译器和处理器的特性考虑在内，执行起来效率更高。 任务建模终极目标是不用为调度每个任务或者工作单位启动新线程。实质上是把它们做成可以调用的代码，由执行者调用，而不是直接可运行的线程。对任务建模的三种方法：Callable，Future和FutureTask CallableCallable代表一段可以调用并放回结果的代码，有单一抽象方法call()。Callable是SAM类型(“单一抽象方法”的缩写)的示例——这是Java 7把函数作为一等类型最可行的办法。 FutureFuture接口用来表示异步任务，是还没有完成的任务给出的未来结果。主要方法： get(): 用来获取结果，如果结果没准备好，会阻塞直到能取到结果。还有超时版本，永远不会阻塞 cancel() : 在运算结束前取消 isDone(): 调用者用它来判断运算是否结束 FutureTaskFutureTask类是Future接口的常用实现类，同时实现了Runnable接口，这意味着它可以由执行者调度，对外提供的方法基本是future和runnable接口的组合, get(), cancel(), isDone(), isCancelled(), run()。 FutureTask还提供了两个很方便的构造器，一个以Runnable为参数，一个以Callable为参数。 线程池1. ThreadPoolExecutor最小线程数：当任务队列为空时，线程池中最少需要保持的线程数量，这样做是考虑创建线程时一个相对耗费资源的操作，应该尽量避免，当有新任务被投入队列时，总有线程立刻处理。最大线程数：当需要处理的任务过多时，线程池能够拥有的最大线程数。这样做事为了保证不会创建过多线程，线程运行需要依赖CPU等资源，线程过多会降低性能。线程池任务数量：线程池有一个列表或者队列来存放需要被执行的任务，当任务数量达到最大时再尝试增加新任务会失败。ThreadPoolExecutor有一个rejectedExecution方法来拒绝该任务。定制ThreadPoolExecutor：线程池同时满足以下条件就会创建一个新的线程： 有任务需要被执行 当前线程池中所有线程都处于工作状态 当前线程池中线程数没有达到最大线程数根据任务队列种类，创建方式分为： SynchronousQueue:这个队列的特点是不能放置任何任务在队列中，当有任务被提交时使用SynchronousQueue的线程池会立即为该任务创建一个线程（如果线程数量达到最大时该任务会被拒绝）。这种队列适合任务数量小的时候采用。 无限队列:例如LinkedBlockingQueue,如何被提交的任务都不会被拒绝，线程池会忽略最大线程这一参数，意味着线程池的最大线程数就变成了设置的最小线程数。所以在使用这种队列时，通常将最大线程和最小线程设置成相等，相当于使用固定线程数量的线程池。 有限队列:例如ArrayBlockingQueue，当最小线程都在工作状态而且队列已满，线程池才会创建新线程从队列中拿走任务。 2. ForkJoinPool处理器的速度增长迅猛，由此产生的副作用就是处理器等待I/O操作变成了家常便饭，这表明我们能够更好地利用计算机的处理速度，分支/合并框架可以解决这个问题。合并/分支框架基本原理： 引入新的执行者服务—ForkJoinPool ForkJoinPool服务处理一种比线程“更小”的并发单元—ForkJoinTask ForkJoinTask是一种由ForkJoinPool以更轻量化的方式所调度的抽象 通常使用两种任务(都表示为ForkJoinTask实例)：小型任务是无需处理器耗费太多时间就可以直接执行的任务，大型任务是需要在直接执行前进行分解（可能不止一次）的任务 提供支持大型任务分解的基本方法，它还有自动调度和重新调度的能力 ForkJoinPool使用无线队列来保存要执行的任务，线程数量通过构造函数传入，如果没有向构造函数传入希望的线程数量，那么当前计算机可用的CPU数量会被设置成线程数量。使用ForkJoinPool时，能够让其中的线程创建新的任务，并挂起当前任务，此时线程就能够从队列中选择子任务执行。ForkJoinPool的另外一个特性是它能够实现工作窃取(Work Stealing)，在该线程池的每个线程中会维护一个队列来存放需要被执行的任务。当线程自身队列中的任务都执行完毕后，它会从别的线程中拿到未被执行的任务并帮助它执行。所以一个结论就是：当任务的任务量均衡时，选择ThreadPoolExecutor往往更好(ForkJoinPool会创建子任务，导致GC工作量增加)，反之则选择ForkJoinPool。另一个影响ForkJoinPool性能的因素是停止进行任务分割的阈值。要把任务提交到这个池，必须创建RecursiveTask的一个子类，其中R是并行化任务以及所有子任务产生的结果类型。如果不返回结果，则是RecursiveAction类型。要定义RecursiveTask，只需实现唯一的抽象方法compute()。在compute()方法中使用fork(), compute(), join()创建子任务并合并结果。fork()方法利用另一个ForkJoinPool线程异步执行新创建的子任务，join()读取子任务结果，如果尚未完成则等待。 使用分支/合并框架的最佳做法： 对一个任务调用join方法会阻塞调用方，因此有必要在两个子任务的计算都开始之后再调用它。 不应该在RecursiveTask内部使用ForkJoinPool的invoke方法，应该直接调用compute或fork方法，只有顺序代码才应该用invoke启动并行运算。 fork()会用另一个线程来处理子任务，同时对左边和右边子任务调用fork()方法效率比直接对其中一个调用compute低，这样可以为其中一个子任务重用同一线程，避免线程池多分配一个任务造成的开销。 一个任务可以分解成多个独立的子任务才能让性能在并行化时有所提升 3. 自动并行化Java 8引入了自动并行化概念，能够让一部分Java代码自动并行方式执行，例如parrellStream。Java 8为ForkJoinPool添加了一个通用线程池，用来处理没有被显示提交到任何线程池的任务，默认线程数量等于运行计算机上的处理器数量。但是这样存在一个严重的问题：该池是所有并行流共享的。默认情况，fork/join池会为每个处理器分配一个线程。假设你有一台16核的机器，这样你就只能创建16个线程。对CPU密集型的任务来说，这样是有意义的，因为你的机器确实只能执行16个线程，IO密集型任务会出现相互等待而被阻塞。 参考：《Java并发编程的艺术》– 方腾飞, 魏鹏, 程晓明等《Java程序员修炼之道》– Benjamin J.Evans, Martijn Verburg]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于《龙族》]]></title>
    <url>%2F2017%2F10%2F21%2F%E5%85%B3%E4%BA%8E%E3%80%8A%E9%BE%99%E6%97%8F%E3%80%8B%2F</url>
    <content type="text"><![CDATA[听说《上海堡垒》要拍电影了，想来江南是要忙着做编剧去了，不知道龙五又要等到什么时候。谈到《龙族》不得不吐槽作者，还从来没见过哪个作家拖稿的时间比写书都长的，毕竟他主业太多，写书只是副业。 我从大一开始追海贼和妖尾，追龙族却是从高二开始的。今年妖尾完结了，龙五还遥遥无期。高中的时候没多少课余时间，一周只有半天假，也还是磕磕绊绊地追了两部。因为爱屋及乌，后来又看了《此间的少年》和《九州缥缈录》，但都不像龙族这样让我钟意。 龙族并不是第一眼就讨人喜欢的，主角又衰又懦弱，一副小心翼翼垂头丧气的样子，读起来并不酣畅淋漓。诺诺正是在他最糗的时候出场的。 人一生里总有几次觉得自己看见了天堂之门洞开，路明非等了十八年，在他最衰的那一刻，门开了。 她光芒四射，目光如刀，牵起这个衰仔，高傲地穿过人群。我最开始并不喜欢路明非，吸引我看下去的是满身棱角，骄傲又耀眼的诺诺。 看龙族的女生可能有三分之一喜欢凯撒，英俊，多金，霸道，偏偏又专一，找不到破绽。应该还有三分之一喜欢楚子航，沉默，冷静，仗义，又强得离谱。余下的大概也没多少喜欢路明非，因为他确实从头衰到脚。然而路明非才是大部分人的样子。有想做的事，想保护的人，但是他实在太衰了，只能窝在角落里，目光呆滞，盯着聚光灯下的凯撒牵着诺诺的手，还要嘟囔着学姐你要幸福这样的烂话。 最孤单的人分两种，一种恨不得全世界都跟他一样倒霉，一种则希望别人能幸福，因为看到幸福的人，他也略略觉得温暖。 他总是这样衰，衰到忘记是自己卖掉灵魂斩了龙王，是自己在三峡水底拼命救下的诺诺。他做了想做的事，保护了要保护的人，站在聚光灯下的依然不是他，于是他认了命，以为自己只能是个衰人。我一直在等待路明非撕掉懦弱的面具，穿越荒原，竖起战旗，哪怕失去灵魂，背叛世界，也不要耷拉着脑袋，满嘴烂话。但是直到第四部，他还是唯唯诺诺灰头土脸。 龙族是本很难定性的小说。它看起来像是中二的屠龙故事，又好像是衰仔的自我救赎。谁也不知道江南最想表达什么，但我看来它更像是孤独者的狂欢。这里几乎每一个主角都是孤独的。 凯撒似乎是最不应该孤独的。他几乎拥有一切，生来就是领袖，注定是屠龙的英雄。于是便也没有人在乎，其实他也只是个破小孩。当他遇到诺诺，好像从井口照下一道光，人生中又多了其他寄托。凯撒这样的人，愿意满世界地追着一个女孩跑，也就不难理解了。他那么孤独，如果没有诺诺，就只有自己一个人了。 楚子航则不同，他是一眼就看得出的孤独。他的孤独是因为愧疚。雨中的高架桥上，看着嬉皮笑脸一事无成的老爸挥舞着太刀淹没在死侍中，他只能开着迈巴赫惊恐地逃走。从那天起他再也没有畏惧过，即使一个人面对龙王。对于楚子航，最大的荣耀应该是和父亲一起战死吧。后来他遇到了夏弥，似乎终于有人要从孤独中拉他出来了。楚子航动了心，女孩却是条龙，他最后的牵绊也留在北京地铁下的尼伯龙根里了。 昂热的孤独隐藏得更深。他的孤独是仇恨，是屠龙的狂热。一个一百多岁的老头，每天混迹于上流酒宴，搂着法国名模谈笑风生。但当他面对真正的龙类时似乎变了一个人。不再温文尔雅，像是杀红眼的亡命之徒。只有那些跟他一样老得掉了牙的伙计才知道，眼看着同伴一个一个死在面前，昂热是怎么坚持活下来的。他孤独到靠着仇恨支撑自己生的希望。 而路明非，大概是孤独的极点了。明知道什么事都不可能，还非要揣着希望，明明想为什么人把命都赌上，可是连下注的理由都没有。 你最爱的人，你为他做了很多事，但他不知道，因为你觉得做这些事都是应该的，你忘记跟他说了。 他的孤独，是从不被需要。没有人觉得他多重要，没有人关心他做了什么，渐渐连他自己都觉得自己是多余的。唯一关心他的人，是一心要买断他灵魂的路鸣泽。这是一个死结，只有他歇斯底里卖掉灵魂的时候，才略微感觉自己被需要，可当他真的卖光了灵魂，就只剩下无尽的孤独了。不管是人还是龙，路明非都注定踽踽独行。 路明非并不是一直这么可怜，至少有一段时间不是。龙族里的女性角色都很棒，不论是零，诺诺，酒德麻衣还是苏恩曦，但是绘离衣更让人难忘。很多人最开始喜欢绘离衣，大概是因为只有她喜欢路明非吧。她血统纯正，心智却不足，就像活在自己世界里的孩子，很难定义她对路明非的喜欢。但是对她来说，路明非一定很重要，比自己都重要。 “04.24，和Sakura去东京天空树，世界上最暖和的地方在天空树的顶上。”“04.25，和Sakura去明治神宫，有人在那里举办婚礼。”“04.26，和Sakura去迪士尼，鬼屋很可怕，但是有Sakura在，所以不可怕。”“Sakura最好了。” 绘离衣的日记里都是他。你以为她是公主拥有全世界，可她以为她只有你和她的玩具们。路明非明明那么渴望关心，终于有人视他如生命却没有抓住。小怪兽终究要被正义的奥特曼杀死，他没能像救诺诺那样救绘离衣。真可悲，为了救诺诺，路明非毅然决然地卖掉灵魂，但是救绘离衣的时候他却犹豫了，即使她说Sakura最好了。江南收了那么多刀片还是写死了绘离衣，也许他觉得路明非就应该是一个人，是走向深渊，还是涅槃重生。 龙族的故事本身并不是一个悲剧，恰好相反，它读起来更像是一本轻喜剧。江南把孤独和死亡都表达的不那么沉重。只是读书的人习惯把自己代入角色，揣测文字下面的情感。 Lonely kid hides in heart. 每个人心里都住着一个死小孩。我甚至有些期待路明非把灵魂卖光的时刻，即使变成魔鬼，会遗忘，会哭泣，也好过把自己扮成小丑，笑的那么难看。在龙四的结尾，路明非卖掉自己最后四分之一的灵魂，依旧是为了诺诺。这次，诺诺看见了他，也终于记起三峡水底大喊着不要死的那张脸，狰狞而悲伤。当孤独的死小孩拥有了力量，即使是奥丁，即使是昆古尼尔也没法洞穿他。利爪和重剑划出黑红色的血丝，咆哮厮杀，王与王的战争，唯有死亡可以终止。希望南大还想得起龙五，毕竟看了这么久的傻猴子，如今他终于想起自己叫孙悟空了，也该让我们看看他身披金甲，踏破凌霄。不管结果如何，至少希望傻猴子能过得逍遥自在。 未完待续]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>小说</tag>
        <tag>龙族</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 - CompletableFuture]]></title>
    <url>%2F2017%2F10%2F18%2FJava-8-CompletableFuture%2F</url>
    <content type="text"><![CDATA[概览Java 8新增了CompletableFuture类，和stream类似，CompletableFuture也使用了Lambda表达式以及流水线思想，从这个角度来说CompletableFuture和Future的关系就跟Stream和Collection一样。既然CompletableFuture和Stream在设计上有相似之处，而且stream提供了并行流，不妨先从比较两者的关系入手。CompletableFuture类提供了大量精巧的工厂方法，使用这些方法能更容易地完成整个流程：先看其中一个工厂方法的两个版本：123public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier);public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor);supplyAsync接受生产者Supplier作为参数返回CompletableFuture对象，对象完成异步执行后会读取调用生产者方法返回值。第一种版本会把生产者方法交由ForkJoinPool池中的某个执行线程，第二种重载版本传递第二个参数指定线程执行生产者方法。《Java 8实战》中有一个比较CompletableFuture和并行流的例子: 如果一个方法需要去查询所有商店某个产品的价格，获取产品价格的方法为getPrice(String product)，假设这个方法会向商店发出网络请求并操作数据库，耗时较多。首先是顺序查询方式：12345public List&lt;String&gt; findPrices(String product)&#123; return shops.stream() .map(shop -&gt; String.format("s% price is %.2f", shop.getName(), shop.getPrice(product))) .collect(Collectors.toList());&#125;串行方法很容易理解，对一个shop列表进行流操作，依次得到每个商店该产品的价格。下面来看并行流的方式：12345public List&lt;String&gt; findPrices(String product)&#123; return shops.parallelStream() .map(shop -&gt; String.format("s% price is %.2f", shop.getName(), shop.getPrice(product))) .collect(Collectors.toList());&#125;接下来是CompletableFuture方式：123456789public List&lt;String&gt; findPrices(String product)&#123; list&lt;CompletableFuture&lt;String&gt;&gt; priceFutures = shops.stream() .map(shop -&gt; CompletableFuture.supplyAsync( () -&gt; shop.getName() + "price is" + shop.getPrice(product))) .collect(Collectors.toList()); return priceFutures.stream() .map(CompletableFuture::join) //join方法和Future的get有相同含义，唯一不同是不会抛异常 .collect(Collectors.toList());&#125;CompletableFuture和并行流很像，内部都采用同样的通用线程池，默认都是用固定数目的线程，具体线程数取决于Runtime.getRuntime.availableProcessors()的返回值。如果通用线程池大小是8，当getPrice()方法延迟足够长而商店数量增多的时候， 上面并行流和CompletableFuture方式的性能都会下降，因为8个线程都处于忙碌状态，之后的查询都要等待前面操作释放出空闲线程。并行流很难解决这种场景，而CompletableFuture具有并行流API无法提供的优势，它允许对执行器Executor进行配置，尤其是线程池的大小。定制执行器：123private final Executor executor = Executors.newFixedThreadPool(100);...CompletableFuture.supplyAsync(() -&gt; shop.getName() + "price is" + shop.getPrice(product), executor);这样商店数目增加就不会影响效率了。总结：并行流和分支/合并框架更适用于实现并行处理，而CompletableFuture更适合实现并发，在同一个CPU上执行松耦合任务，充分利用CPU的核，所以CompletableFuture更适合IO密集型任务，并行流和ForkJoinPool更适合CPU密集型任务。 使用CompletableFuture1. 创键获取CompletableFuture1234static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier);static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor);static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable);static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor); runAsync需要Runnable为参数，不返回任何值，如果需要处理异步操作并返回结果使用supplyAsync. 2. 组合futures12345678//thenApply 参数function的函数描述符为 T -&gt; U&lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn);&lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn);&lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor);//thenCompose 参数function的函数描述符为 T -&gt; CompletableFuture&lt;U&gt;&lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn);&lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn);&lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor); 从方法定义看，thenCompose可以接受一个function作为参数，这个function的函数描述符是T -&gt; CompletableFuture&lt;U&gt;，它允许对两个异步操作复合流水线，比如创建两个CompletableFuture对象，对第一个CompletableFuture对象调用thenCompose，并向它传递一个函数，当第一个CompletableFuture执行完毕后，结果将作为该函数的参数，这个函数的返回值是以第一个CompletableFuture返回作为输入计算出的第二个CompletableFuture对象。例子(只为了展示用法)：首先创建一个double集合，然后第一个CompletableFuture取每一个double的intValue()，当执行完毕时调用thenCompose方法，将执行结果作为thenCompose参数中的函数的参数，计算第二个CompletableFuture对象，把每个整型转换成字符串。最后输出的结果是1 2 3 4 5。 3. 整合futures，无论是否依赖123456&lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn);&lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn);&lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor); 第二个参数BiFunction定义如何将两个CompletableFuture的结果组合在一起。 4. completion事件之前所说的例子都是在所有商店的返回值都取得之后才显示商品价格。如果想要商店返回商品价格第一时间就显示返回值就需要completion事件。12345678//thenAcceptCompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action);CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action);CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor);//thenRunCompletableFuture&lt;Void&gt; thenRun(Runnable action);CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action);CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action, Executor executor);CompletableFuture类中还提供了一些其他的completion事件，可以看做给CompletableFuture注册一个回调函数，在Future执行完毕或者计算结果可用时针对性执行一些程序。 参考：《Java 8函数式编程》– Richard Warburton《Java 8 in Action》– Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
        <tag>CompletableFuture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 - Stream]]></title>
    <url>%2F2017%2F10%2F17%2FJava-8-Stream%2F</url>
    <content type="text"><![CDATA[流的概念流允许以声明式方式处理数据集合，可以姑且把它们看成遍历数据集的高级迭代器。此外流可以透明地并行处理。 1.优点 声明性 — 更简洁，更易读 可复合 — 更灵活 可并行 — 性能更好 2.流操作有两个重要的特点 流水线 — 很多流操作本身会返回一个流，这样多个操作就可以链接起来形成流水线。 内部迭代 — 流的迭代在背后进行，与显式使用迭代器不同。 3.集合和流的区别在于什么时候计算。集合中的每个元素都要先算出来才添加到集合中，流则是在概念上固定的数据结构，其元素是按需计算的。这个思想是用户仅仅从流中提取需要的值。从另一个角度看流就像延迟创建的集合。 4.流与迭代器类似，只能遍历一次，遍历完这个流就已经被消费掉了。 5.流操作可以分为两类，中间操作和终端操作: 中间操作指可以连接起来的流操作：如filter，sorted，map和limit等，除非流水线触发终端操作，否则中间操作不会执行任何结果。 终端操作可以从流的流水线生成结果，如forEach，collect。 6.使用流一般包括三件事： 一个数据源（如集合）来执行一个操作 一个中间操作链，形成流水线 一个终端操作，执行流水线并生成结果 使用流1. 筛选和切片下面列举几个常见的流12345678//用谓词筛选Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);//筛选各异的元素Stream&lt;T&gt; distinct();//截断流，返回不超过给定长度的流Stream&lt;T&gt; limit(long maxSize);//返回扔掉前n个元素的流，如果流中元素不足n个则返回空流Stream&lt;T&gt; skip(long n);下面代码筛选出苹果中重于100克的第4和第5个苹果。12List&lt;Apple&gt; bigAppleList = appleList.stream().filter(apple -&gt; apple.getWeight() &gt; 100) .limit(5).skip(3).collect(toList()); 2. 映射下面列举几个常见的流123//map方法接受function作为参数，并被应用在每个元素上映射成新的元素&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper);从flatMap的函数定义来看，它接受一个function，而这个function的第二个参数是stream，也就是说函数描述符为T→Stream， Arrays中有stream()方法可以将数组转化成流。等同于：map被应用到数组中的两个字符串”Hello”和”World”中，映射成两个String数组，而我们想要的是Stream&lt;String&gt;而不是Stream&lt;String[]&gt;，如果用map来映射将会得到流的列表，所以需要用flatMap把各个数组映射成一个流。简单来说，flatMap方法会把一个流中的每个值都转换成另一个流，然后把所有流连接起来成为一个流。 3. 查找和匹配12345678910//流中是否有一个元素匹配给定的谓词boolean anyMatch(Predicate&lt;? super T&gt; predicate);//流中的元素是否都能匹配给定的谓词boolean allMatch(Predicate&lt;? super T&gt; predicate);//流中没有元素与给定的谓词匹配boolean noneMatch(Predicate&lt;? super T&gt; predicate);//返回流中任意元素。流水线将会利用短路找到结果立即结束Optional&lt;T&gt; findAny();//找到第一个元素。在并行上限制较多，如果不关心返回元素是哪一个建议使用findAny()，因为它在并行流上限制较少Optional&lt;T&gt; findFirst(); 4. 归约1234// 第一个参数为初始值T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);// 无初始值,考虑流中没有任何元素的情况，reduce无法返回和，所以结果包裹在Optional对象里以表明和可能不存在Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); 想计算整型数组的和：结果是20。reduce() 也可以用来求最大值或者最小值。 数值流和函数式接口的原始类型特化一样，为避免装箱拆箱成本，Stream API提供了数值流。Java 8引入三个原始类型特化流：IntStream, DoubleStream和LongStream, 分别将流中的元素特化为int，double和long，从而避免了reduce时暗含的拆箱成本。每个接口都带来了进行常用数值归约的新方法，例如count(), max(), min(), average()和sum()等。映射到数值流：123IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper);LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper);DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper);转换回对象流：1Stream&lt;Integer&gt; boxed();使用方法：12IntStream intStream = appleList.stream().mapToInt(Apple::getWeight); //转换成数值流Stream&lt;Integer&gt; stream = intStream.boxed(); //转换成Stream数值流中有很多实用的方法，如求数值范围，IntStream evenNumbers = IntStream.rangeClosed(1, 100); 构建流除了从集合生成流，还有其他几种生成流的方式 1. 由值构建流12Stream&lt;String&gt; stream = Stream.of("zhao", "hong", "yu");Stream&lt;String&gt; emptyStream = Stream.empty(); 2. 由数组构造流12String[] name = &#123;"zhao", "hong", "yu"&#125;;Stream&lt;String&gt; stream = Arrays.stream(name); 3. 由文件生成流java.nio.file.Files中有很多静态方法可以返回一个流，例如Files.lines会返回指定文件中各行构成的字符串流。使用的不多，先不介绍。 4. 由函数生成流Stream API 提供了两个静态方法从函数生成流：Stream.iterate和Stream.generate。这两个操作可以创建无限流。一般会用limit来加以限制1Stream.iterate(0, n -&gt; n+2).limit(100).forEach(System.out::println);生成结果是从0开始公差为2的等差数列的前100项。 用流收集数据终端操作除了count, findFirst, reduce, forEach等，最常用的是collect操作。collect接受Collector作为参数Collectors类提供了很多常用的静态工厂方法生成Collector： 参考：《Java 8函数式编程》– Richard Warburton《Java 8 in Action》– Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 - Lambda]]></title>
    <url>%2F2017%2F10%2F16%2FJava-8-Lambda%2F</url>
    <content type="text"><![CDATA[基本概念从一个例子开始：用Lambda实现一个比较器 12Comparator&lt;Apple&gt; byWeight = (Apple apple1, Apple apple2) -&gt; apple1.getWeight().compareTo(apple2.getWeight()); Lambda表达式有三个部分： 参数列表：两个Apple 箭头：箭头把参数列表和Lambda主体分隔开 Lambda主体：比较两个Apple的重量。表达式就是Lambda的返回值 Lambda表达式的基本语法有两种： (parameters) -&gt; expression (parameters) -&gt; {statements;} 注：expression隐含了return，如果想显示返回语句需要使用第二种statements语法。 何时使用Lambda我们可以在函数式接口上使用Lambda表达式。函数式接口：只定义一个抽象方法的接口(比如例子中的Comparator接口只定义了一个compare()抽象方法)。注：Java 8中新增了默认方法，即在类没有对方法进行实现时，主体为方法提供默认实现的方法。不管有多少默认方法，只要接口只定义了一个抽象方法，它就仍然是一个函数式接口。 函数式接口函数式接口很有用，因为抽象方法的签名可以描述Lambda表达式的签名，函数式接口的抽象方法签名称为函数描述符。java.util.function包中定义了一些常用的函数式接口：(注：@FunctionalInterface 注解用于表示该接口会设计成一个函数式接口。接口代码省略了默认方法)。 1) Predicate1234@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125; Predicate接口定义了一个test抽象方法，接受泛型T对象，返回一个boolean。适用于filter中。 2) Consumer1234@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125; Consumer定义了一个accept抽象方法，接受泛型T对象，没有返回。如果需要访问一个对象并对其执行某些操作就可以使用这个接口。 3) Function1234@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t);&#125; Function接口定义了apply方法，接受泛型T对象，返回泛型R对象。适用于map方法中。 4) 其他函数式接口 函数式接口 抽象方法 BiConsumer&lt;T, U&gt; void accept(T t, U u) BiFunction&lt;T, U, R&gt; R apply(T t, U u) BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; T apply(T t1, T t2) BiPredicate&lt;T, U&gt; boolean test(T t, U u) Supplier&lt;T&gt; T get() UnaryOperator&lt;T&gt; extends Function T apply(T t) 5) 原始类型特化上述函数式接口的抽象方法都使用了泛型，泛型只能绑定引用类型，那么在输入输出是原始类型时会进行自动装箱，影响性能。 java.util.function中提供了专门的函数式接口避免装箱操作。比如: 1234@FunctionalInterfacepublic interface IntPredicate &#123; boolean test(int value);&#125; 如何使用它：12IntPredicate evenNumbers = (int i) -&gt; i% 2 == 0;evenNumbers.test(1000);使用IntPredicate不会对1000装箱，如果用Predicate&lt;Integer&gt;会把1000装到Integer对象中。之前提到的函数式接口都有很多对应的类型特化接口，具体可在java.util.function包中查看。 方法引用方法引用可以看做仅仅调用特定方法的Lambda的一种快捷写法，语法糖。构建方法引用： 指向静态方法的方法引用：例如Integer的parseInt方法，可以写作Integer:parseInt 指向任意类型实例方法的方法引用：例如String的length方法，写作String::length 指向现有对象的实例方法的方法引用：与第二种的区别是第二种是在引用一个对象的方法，而这个对象本身是Lambda的一个参数，第三种方法引用指在Lambda中调用一个已存在的外部对象的方法 复合Lambda表达式多个简单的Lambda表达式可以复合成复杂的表达式，比如让两个Predicate做or操作，或者一个Function的输出作为另一个Function的输入。但是函数式接口只有一个抽象方法，实现复合操作的是前面提到的默认方法。 123456789101112131415@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); &#125; default Predicate&lt;T&gt; negate() &#123; return (t) -&gt; !test(t);&#125; default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); &#125; &#125; Predicate接口除了唯一抽象方法外，还有三个默认方法，negate，and和or，可以重用已有的Predicate来创建更复杂的谓词。 12345678910//苹果是红的Predicate&lt;Apple&gt; redApple = apple -&gt; "red".equals(apple.getColor()); //苹果不是红的Predicate&lt;Apple&gt; notRedApple = redApple.negate(); //苹果是红色又比100克重 Predicate&lt;Apple&gt; redAndHeavyApple = redApple.and(apple -&gt; apple.getWeight() &gt; 100);//苹果是比100克重的红苹果，或者是绿苹果 Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen = redApple.and(apple -&gt; apple.getWeight() &gt; 100) .or(apple -&gt; "Green".equals(apple.getColor())); 一个复合Function的例子： Function接口提供了andThen和compose两个默认方法，andThen相当于 multiply(add(x))，compose相当于 add(multiply(x))。所以上面程序的结果是：4和3。很多函数式接口都有默认方法来结合Lambda表达式复合成更复杂的表达式。 总结Lambda表达式可以理解为一种匿名函数，只有在接受函数式接口的地方才可以使用lambda表达式，它允许直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例。 参考：《Java 8函数式编程》– Richard Warburton《Java 8 in Action》– Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First Move]]></title>
    <url>%2F2017%2F10%2F15%2FFirst-Move%2F</url>
    <content type="text"><![CDATA[“你没有什么话想说吗？” — “有啊”“为什么不说？” — “懒得说”“那就写下来” 为什么做这个博客不知不觉工作了快五个月了，好像每天都有汹涌的信息和新鲜事灌进脑子里，密度远远超过了大学里。我一直在被动地接受新知识的冲击，继而渐渐感到不安。我不知道这些东西在哪，我不知道我有没有抓住他们。当我看到的越多，也就越知道我没看到的更多。 最近似乎独处的时间很多，其实也算不上独处，毕竟每天有超过十个小时窝在公司的椅子里。但是一天下来，好像也没怎么张过嘴。我已经慢慢学不会主动找人说话了，似乎习惯了一个人做事，也乐得清静。这样的生活久了，也就明白了我要依靠的只有自己罢了。 前段时间看了小朋友演的红楼梦，想起我曾经最迷的书就是这本。但是我现在连十二钗都记不全了。如此想来我用了两个暑假看了两遍，好像都在浪费时间了。心里觉得不甘，于是就又买了一套，当看到封面的时候，莫名觉得欣喜又感动，好像又看到了那个夏天，不写暑假作业，偷偷看“杂书”的我。 这些算不上什么理由，也毫无逻辑。我本来也不擅长写东西，不会引经据典，条理不清晰，没有论据论点。那到底为什么要搭这个博客呢？大概是想发现些问题，积累点知识，以后不至于失业吧；大概是一个人呆的时间久了，想做点有意思的事不至于太寂寞吧；大概是想记录下时光，给以后或许会迷茫的自己吧。可能这些原因都有，也可能都不是，我唯一真切地记得的是，昨天晚上躺在床上，脑子里有声音问我有没有什么话想说，突然发现自己也有很多想法要表达。那就做个博客吧。我看了看手机，十二点半，嗯，还早着。于是就一晚上都没睡。 要记录些什么我想，这应该会是个披着技术外衣的生活类博客吧。我给这个博客定的title是dabbler，牛津词典翻译成浅尝者，说白了就是半吊子。我觉得半吊子似乎是对自己很好的诠释。我好像还没有大牛们用技术推动世界的宏伟理想，所以应该会花很多时间来闲扯淡。 当然，不管怎样，至少他应该要穿着那件外衣的。不管工作中还是私下里，遇到的技术问题都值得记下来，看过的书也有必要做些笔记。但是只谈技术未免太严肃，就好像是一个从不洗头不洗澡对着电脑敲一天代码的死宅一样。如果有一天看了哪本小说，可能会记下里面几句话；如果看了哪部动漫，可能会交流二次元文化；如果出去旅游，可能会贴几张照片；如果有一天我遇到另一个人，那可能就有两个人写博客了。 不管怎样，我希望记录的东西不止有意义，有价值，更要有趣。至少对我来说是有趣的。以后有一天看到今天写的东西，还会笑着想那时候我可真蠢啊。 First Move这一篇就暂告一段落了。在写这几百个字的过程中，也算是重新认识自己，我的文笔是真的差。First move是标题，也是结尾，第一篇算是个契机，第一步也不只写篇博客这么肤浅。历史的车轮滚滚向前，哪有时间停滞不前。 竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。 煮碗鸡汤喝，明天又是星期一。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
